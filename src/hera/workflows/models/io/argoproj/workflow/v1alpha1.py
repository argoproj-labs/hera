# generated by datamodel-codegen:
#   filename:  argo-workflows-3.7.3.json

from __future__ import annotations

from typing import Annotated, Any

from pydantic import Base64Str, Field, RootModel

from hera.shared._pydantic import APIBaseModel

from ...k8s.api.core import v1
from ...k8s.api.policy import v1 as v1_2
from ...k8s.apimachinery.pkg.apis.meta import v1 as v1_1
from ...k8s.apimachinery.pkg.util import intstr


class Amount(RootModel[float]):
    root: Annotated[float, Field(description="Amount represent a numeric amount.")]


class NoneStrategy(APIBaseModel):
    pass


class TarStrategy(APIBaseModel):
    compression_level: Annotated[
        int | None,
        Field(
            alias="compressionLevel",
            description=(
                "CompressionLevel specifies the gzip compression level to use for the"
                " artifact. Defaults to gzip.DefaultCompression."
            ),
        ),
    ] = None


class ZipStrategy(APIBaseModel):
    pass


class ArchivedWorkflowDeletedResponse(APIBaseModel):
    pass


class ArtGCStatus(APIBaseModel):
    not_specified: Annotated[
        bool | None,
        Field(
            alias="notSpecified",
            description=("if this is true, we already checked to see if we need to do it and we don't"),
        ),
    ] = None
    pods_recouped: Annotated[
        dict[str, bool] | None,
        Field(
            alias="podsRecouped",
            description=(
                "have completed Pods been processed? (mapped by Pod name) used to"
                " prevent re-processing the Status of a Pod more than once"
            ),
        ),
    ] = None
    strategies_processed: Annotated[
        dict[str, bool] | None,
        Field(
            alias="strategiesProcessed",
            description=(
                "have Pods been started to perform this strategy? (enables us not to"
                " re-process what we've already done)"
            ),
        ),
    ] = None


class RawArtifact(APIBaseModel):
    data: Annotated[str, Field(description="Data is the string contents of the artifact")]


class Metadata(APIBaseModel):
    annotations: dict[str, str] | None = None
    labels: dict[str, str] | None = None


class ArtifactRepositoryRef(APIBaseModel):
    config_map: Annotated[
        str | None,
        Field(
            alias="configMap",
            description=('The name of the config map. Defaults to "artifact-repositories".'),
        ),
    ] = None
    key: Annotated[
        str | None,
        Field(
            description=(
                "The config map key. Defaults to the value of the"
                ' "workflows.argoproj.io/default-artifact-repository" annotation.'
            )
        ),
    ] = None


class ClusterWorkflowTemplateDeleteResponse(APIBaseModel):
    pass


class CollectEventRequest(APIBaseModel):
    name: str | None = None


class CollectEventResponse(APIBaseModel):
    pass


class Column(APIBaseModel):
    key: Annotated[
        str,
        Field(description=('The key of the label or annotation, e.g., "workflows.argoproj.io/completed".')),
    ]
    name: Annotated[str, Field(description='The name of this column, e.g., "Workflow Completed".')]
    type: Annotated[str, Field(description='The type of this column, "label" or "annotation".')]


class Condition(APIBaseModel):
    message: Annotated[str | None, Field(description="Message is the condition message")] = None
    status: Annotated[str | None, Field(description="Status is the status of the condition")] = None
    type: Annotated[str | None, Field(description="Type is the type of condition")] = None


class ContinueOn(APIBaseModel):
    error: bool | None = None
    failed: bool | None = None


class Counter(APIBaseModel):
    value: Annotated[str, Field(description="Value is the value of the metric")]


class CreateS3BucketOptions(APIBaseModel):
    object_locking: Annotated[
        bool | None,
        Field(alias="objectLocking", description="ObjectLocking Enable object locking"),
    ] = None


class CronWorkflowDeletedResponse(APIBaseModel):
    pass


class CronWorkflowResumeRequest(APIBaseModel):
    name: str | None = None
    namespace: str | None = None


class StopStrategy(APIBaseModel):
    expression: Annotated[
        str,
        Field(
            description=(
                "v3.6 and after: Expression is an expression that stops scheduling"
                " workflows when true. Use the variables `cronworkflow`.`failed` or"
                " `cronworkflow`.`succeeded` to access the number of failed or"
                " successful child workflows."
            )
        ),
    ]


class CronWorkflowSuspendRequest(APIBaseModel):
    name: str | None = None
    namespace: str | None = None


class TemplateRef(APIBaseModel):
    cluster_scope: Annotated[
        bool | None,
        Field(
            alias="clusterScope",
            description=(
                "ClusterScope indicates the referred template is cluster scoped (i.e. a ClusterWorkflowTemplate)."
            ),
        ),
    ] = None
    name: Annotated[str | None, Field(description="Name is the resource name of the template.")] = None
    template: Annotated[
        str | None,
        Field(description="Template is the name of referred template in the resource."),
    ] = None


class Event(APIBaseModel):
    selector: Annotated[
        str,
        Field(
            description=(
                "Selector (https://github.com/expr-lang/expr) that we must must match"
                ' the io.argoproj.workflow.v1alpha1. E.g. `payload.message == "test"`'
            )
        ),
    ]


class EventResponse(APIBaseModel):
    pass


class ExecutorConfig(APIBaseModel):
    service_account_name: Annotated[
        str | None,
        Field(
            alias="serviceAccountName",
            description=("ServiceAccountName specifies the service account name of the executor container."),
        ),
    ] = None


class Gauge(APIBaseModel):
    operation: Annotated[
        str | None,
        Field(description=("Operation defines the operation to apply with value and the metrics' current value")),
    ] = None
    realtime: Annotated[bool, Field(description="Realtime emits this metric in real time if applicable")]
    value: Annotated[
        str,
        Field(
            description=(
                "Value is the value to be used in the operation with the metric's"
                " current value. If no operation is set, value is the value of the"
                " metric"
            )
        ),
    ]


class GetUserInfoResponse(APIBaseModel):
    email: str | None = None
    email_verified: Annotated[bool | None, Field(alias="emailVerified")] = None
    groups: list[str] | None = None
    issuer: str | None = None
    name: str | None = None
    service_account_name: Annotated[str | None, Field(alias="serviceAccountName")] = None
    service_account_namespace: Annotated[str | None, Field(alias="serviceAccountNamespace")] = None
    subject: str | None = None


class HTTPBodySource(APIBaseModel):
    bytes: Base64Str | None = None


class Header(APIBaseModel):
    name: Annotated[str, Field(description="Name is the header name")]
    value: Annotated[str, Field(description="Value is the literal value to use for the header")]


class Histogram(APIBaseModel):
    buckets: Annotated[
        list[Amount],
        Field(description="Buckets is a list of bucket divisors for the histogram"),
    ]
    value: Annotated[str, Field(description="Value is the value of the metric")]


class Item(RootModel[Any]):
    root: Annotated[
        Any,
        Field(
            description=(
                "Item expands a single workflow step into multiple parallel steps The"
                " value of Item can be a map, string, bool, or number"
            )
        ),
    ]


class LabelKeys(APIBaseModel):
    items: list[str] | None = None


class LabelValueFrom(APIBaseModel):
    expression: str


class LabelValues(APIBaseModel):
    items: list[str] | None = None


class Link(APIBaseModel):
    name: Annotated[
        str,
        Field(description='The name of the link, E.g. "Workflow Logs" or "Pod Logs"'),
    ]
    scope: Annotated[
        str,
        Field(
            description=(
                '"workflow", "pod", "pod-logs", "event-source-logs", "sensor-logs", "workflow-list" or "chat"'
            )
        ),
    ]
    url: Annotated[
        str,
        Field(
            description=(
                'The URL. Can contain "${metadata.namespace}", "${metadata.name}",'
                ' "${status.startedAt}", "${status.finishedAt}" or any other element in'
                " workflow yaml, e.g."
                ' "${io.argoproj.workflow.v1alpha1.metadata.annotations.userDefinedKey}"'
            )
        ),
    ]


class LogEntry(APIBaseModel):
    content: str | None = None
    pod_name: Annotated[str | None, Field(alias="podName")] = None


class MemoizationStatus(APIBaseModel):
    cache_name: Annotated[
        str,
        Field(
            alias="cacheName",
            description="Cache is the name of the cache that was used",
        ),
    ]
    hit: Annotated[
        bool,
        Field(description="Hit indicates whether this node was created from a cache entry"),
    ]
    key: Annotated[str, Field(description="Key is the name of the key used for this node's cache")]


class MetricLabel(APIBaseModel):
    key: str
    value: str


class Mutex(APIBaseModel):
    database: Annotated[
        bool | None,
        Field(description=("Database specifies this is database controlled if this is set true")),
    ] = None
    name: Annotated[str | None, Field(description="name of the mutex")] = None
    namespace: Annotated[
        str | None,
        Field(description=("Namespace is the namespace of the mutex, default: [namespace of workflow]")),
    ] = None


class MutexHolding(APIBaseModel):
    holder: Annotated[
        str | None,
        Field(
            description=(
                "Holder is a reference to the object which holds the Mutex. Holding"
                " Scenario:\n  1. Current workflow's NodeID which is holding the"
                " lock.\n     e.g: ${NodeID}\nWaiting Scenario:\n  1. Current workflow"
                " or other workflow NodeID which is holding the lock.\n     e.g:"
                " ${WorkflowName}/${NodeID}"
            )
        ),
    ] = None
    mutex: Annotated[
        str | None,
        Field(description="Reference for the mutex e.g: ${namespace}/mutex/${mutexName}"),
    ] = None


class MutexStatus(APIBaseModel):
    holding: Annotated[
        list[MutexHolding] | None,
        Field(
            description=(
                "Holding is a list of mutexes and their respective objects that are"
                " held by mutex lock for this io.argoproj.workflow.v1alpha1."
            )
        ),
    ] = None
    waiting: Annotated[
        list[MutexHolding] | None,
        Field(description=("Waiting is a list of mutexes and their respective objects this workflow is waiting for.")),
    ] = None


class NodeFlag(APIBaseModel):
    hooked: Annotated[
        bool | None,
        Field(description=("Hooked tracks whether or not this node was triggered by hook or onExit")),
    ] = None
    retried: Annotated[
        bool | None,
        Field(description=("Retried tracks whether or not this node was retried by retryStrategy")),
    ] = None


class NodeSynchronizationStatus(APIBaseModel):
    waiting: Annotated[
        str | None,
        Field(description="Waiting is the name of the lock that this node is waiting for"),
    ] = None


class OAuth2EndpointParam(APIBaseModel):
    key: Annotated[str, Field(description="Name is the header name")]
    value: Annotated[
        str | None,
        Field(description="Value is the literal value to use for the header"),
    ] = None


class OSSLifecycleRule(APIBaseModel):
    mark_deletion_after_days: Annotated[
        int | None,
        Field(
            alias="markDeletionAfterDays",
            description=("MarkDeletionAfterDays is the number of days before we delete objects in the bucket"),
        ),
    ] = None
    mark_infrequent_access_after_days: Annotated[
        int | None,
        Field(
            alias="markInfrequentAccessAfterDays",
            description=(
                "MarkInfrequentAccessAfterDays is the number of days before we convert"
                " the objects in the bucket to Infrequent Access (IA) storage type"
            ),
        ),
    ] = None


class Plugin(APIBaseModel):
    pass


class ResubmitArchivedWorkflowRequest(APIBaseModel):
    memoized: bool | None = None
    name: str | None = None
    namespace: str | None = None
    parameters: list[str] | None = None
    uid: str | None = None


class RetryNodeAntiAffinity(APIBaseModel):
    pass


class RetryArchivedWorkflowRequest(APIBaseModel):
    name: str | None = None
    namespace: str | None = None
    node_field_selector: Annotated[str | None, Field(alias="nodeFieldSelector")] = None
    parameters: list[str] | None = None
    restart_successful: Annotated[bool | None, Field(alias="restartSuccessful")] = None
    uid: str | None = None


class SemaphoreHolding(APIBaseModel):
    holders: Annotated[
        list[str] | None,
        Field(description=("Holders stores the list of current holder names in the io.argoproj.workflow.v1alpha1.")),
    ] = None
    semaphore: Annotated[str | None, Field(description="Semaphore stores the semaphore name.")] = None


class SyncDatabaseRef(APIBaseModel):
    key: str


class SemaphoreStatus(APIBaseModel):
    holding: Annotated[
        list[SemaphoreHolding] | None,
        Field(description=("Holding stores the list of resource acquired synchronization lock for workflows.")),
    ] = None
    waiting: Annotated[
        list[SemaphoreHolding] | None,
        Field(description=("Waiting indicates the list of current synchronization lock holders.")),
    ] = None


class WorkflowTemplateRef(APIBaseModel):
    cluster_scope: Annotated[
        bool | None,
        Field(
            alias="clusterScope",
            description=(
                "ClusterScope indicates the referred template is cluster scoped (i.e. a ClusterWorkflowTemplate)."
            ),
        ),
    ] = None
    name: Annotated[
        str | None,
        Field(description="Name is the resource name of the workflow template."),
    ] = None


class SuppliedValueFrom(APIBaseModel):
    pass


class SuspendTemplate(APIBaseModel):
    duration: Annotated[
        str | None,
        Field(
            description=(
                "Duration is the seconds to wait before automatically resuming a"
                " template. Must be a string. Default unit is seconds. Could also be a"
                ' Duration, e.g.: "2m", "6h"'
            )
        ),
    ] = None


class TTLStrategy(APIBaseModel):
    seconds_after_completion: Annotated[
        int | None,
        Field(
            alias="secondsAfterCompletion",
            description=("SecondsAfterCompletion is the number of seconds to live after completion"),
        ),
    ] = None
    seconds_after_failure: Annotated[
        int | None,
        Field(
            alias="secondsAfterFailure",
            description=("SecondsAfterFailure is the number of seconds to live after failure"),
        ),
    ] = None
    seconds_after_success: Annotated[
        int | None,
        Field(
            alias="secondsAfterSuccess",
            description=("SecondsAfterSuccess is the number of seconds to live after success"),
        ),
    ] = None


class TransformationStep(APIBaseModel):
    expression: Annotated[str, Field(description="Expression defines an expr expression to apply")]


class Version(APIBaseModel):
    build_date: Annotated[str, Field(alias="buildDate")]
    compiler: str
    git_commit: Annotated[str, Field(alias="gitCommit")]
    git_tag: Annotated[str, Field(alias="gitTag")]
    git_tree_state: Annotated[str, Field(alias="gitTreeState")]
    go_version: Annotated[str, Field(alias="goVersion")]
    platform: str
    version: str


class VolumeClaimGC(APIBaseModel):
    strategy: Annotated[
        str | None,
        Field(
            description=(
                'Strategy is the strategy to use. One of "OnWorkflowCompletion",'
                ' "OnWorkflowSuccess". Defaults to "OnWorkflowSuccess"'
            )
        ),
    ] = None


class WorkflowDeleteResponse(APIBaseModel):
    pass


class WorkflowMetadata(APIBaseModel):
    annotations: dict[str, str] | None = None
    labels: dict[str, str] | None = None
    labels_from: Annotated[dict[str, LabelValueFrom] | None, Field(alias="labelsFrom")] = None


class WorkflowResubmitRequest(APIBaseModel):
    memoized: bool | None = None
    name: str | None = None
    namespace: str | None = None
    parameters: list[str] | None = None


class WorkflowResumeRequest(APIBaseModel):
    name: str | None = None
    namespace: str | None = None
    node_field_selector: Annotated[str | None, Field(alias="nodeFieldSelector")] = None


class WorkflowRetryRequest(APIBaseModel):
    name: str | None = None
    namespace: str | None = None
    node_field_selector: Annotated[str | None, Field(alias="nodeFieldSelector")] = None
    parameters: list[str] | None = None
    restart_successful: Annotated[bool | None, Field(alias="restartSuccessful")] = None


class WorkflowSetRequest(APIBaseModel):
    message: str | None = None
    name: str | None = None
    namespace: str | None = None
    node_field_selector: Annotated[str | None, Field(alias="nodeFieldSelector")] = None
    output_parameters: Annotated[str | None, Field(alias="outputParameters")] = None
    phase: str | None = None


class WorkflowStopRequest(APIBaseModel):
    message: str | None = None
    name: str | None = None
    namespace: str | None = None
    node_field_selector: Annotated[str | None, Field(alias="nodeFieldSelector")] = None


class WorkflowSuspendRequest(APIBaseModel):
    name: str | None = None
    namespace: str | None = None


class WorkflowTemplateDeleteResponse(APIBaseModel):
    pass


class WorkflowTerminateRequest(APIBaseModel):
    name: str | None = None
    namespace: str | None = None


class CronWorkflowStatus(APIBaseModel):
    active: Annotated[
        list[v1.ObjectReference] | None,
        Field(description=("Active is a list of active workflows stemming from this CronWorkflow")),
    ] = None
    conditions: Annotated[
        list[Condition] | None,
        Field(description="Conditions is a list of conditions the CronWorkflow may have"),
    ] = None
    failed: Annotated[
        int | None,
        Field(description=("v3.6 and after: Failed counts how many times child workflows failed")),
    ] = None
    last_scheduled_time: Annotated[
        v1_1.Time | None,
        Field(
            alias="lastScheduledTime",
            description=("LastScheduleTime is the last time the CronWorkflow was scheduled"),
        ),
    ] = None
    phase: Annotated[
        str | None,
        Field(
            description=(
                "v3.6 and after: Phase is an enum of Active or Stopped. It changes to"
                " Stopped when stopStrategy.expression is true"
            )
        ),
    ] = None
    succeeded: Annotated[
        int | None,
        Field(description=("v3.6 and after: Succeeded counts how many times child workflows succeeded")),
    ] = None


class ArtifactoryArtifact(APIBaseModel):
    password_secret: Annotated[
        v1.SecretKeySelector | None,
        Field(
            alias="passwordSecret",
            description=("PasswordSecret is the secret selector to the repository password"),
        ),
    ] = None
    url: Annotated[str, Field(description="URL of the artifact")]
    username_secret: Annotated[
        v1.SecretKeySelector | None,
        Field(
            alias="usernameSecret",
            description=("UsernameSecret is the secret selector to the repository username"),
        ),
    ] = None


class ArtifactoryArtifactRepository(APIBaseModel):
    key_format: Annotated[
        str | None,
        Field(
            alias="keyFormat",
            description=("KeyFormat defines the format of how to store keys and can reference workflow variables."),
        ),
    ] = None
    password_secret: Annotated[
        v1.SecretKeySelector | None,
        Field(
            alias="passwordSecret",
            description=("PasswordSecret is the secret selector to the repository password"),
        ),
    ] = None
    repo_url: Annotated[
        str | None,
        Field(alias="repoURL", description="RepoURL is the url for artifactory repo."),
    ] = None
    username_secret: Annotated[
        v1.SecretKeySelector | None,
        Field(
            alias="usernameSecret",
            description=("UsernameSecret is the secret selector to the repository username"),
        ),
    ] = None


class AzureArtifact(APIBaseModel):
    account_key_secret: Annotated[
        v1.SecretKeySelector | None,
        Field(
            alias="accountKeySecret",
            description=("AccountKeySecret is the secret selector to the Azure Blob Storage account access key"),
        ),
    ] = None
    blob: Annotated[
        str,
        Field(description=("Blob is the blob name (i.e., path) in the container where the artifact resides")),
    ]
    container: Annotated[
        str,
        Field(description="Container is the container where resources will be stored"),
    ]
    endpoint: Annotated[
        str,
        Field(
            description=(
                "Endpoint is the service url associated with an account. It is most"
                ' likely "https://<ACCOUNT_NAME>.blob.core.windows.net"'
            )
        ),
    ]
    use_sdk_creds: Annotated[
        bool | None,
        Field(
            alias="useSDKCreds",
            description=("UseSDKCreds tells the driver to figure out credentials based on sdk defaults."),
        ),
    ] = None


class AzureArtifactRepository(APIBaseModel):
    account_key_secret: Annotated[
        v1.SecretKeySelector | None,
        Field(
            alias="accountKeySecret",
            description=("AccountKeySecret is the secret selector to the Azure Blob Storage account access key"),
        ),
    ] = None
    blob_name_format: Annotated[
        str | None,
        Field(
            alias="blobNameFormat",
            description=(
                "BlobNameFormat is defines the format of how to store blob names. Can reference workflow variables"
            ),
        ),
    ] = None
    container: Annotated[
        str,
        Field(description="Container is the container where resources will be stored"),
    ]
    endpoint: Annotated[
        str,
        Field(
            description=(
                "Endpoint is the service url associated with an account. It is most"
                ' likely "https://<ACCOUNT_NAME>.blob.core.windows.net"'
            )
        ),
    ]
    use_sdk_creds: Annotated[
        bool | None,
        Field(
            alias="useSDKCreds",
            description=("UseSDKCreds tells the driver to figure out credentials based on sdk defaults."),
        ),
    ] = None


class BasicAuth(APIBaseModel):
    password_secret: Annotated[
        v1.SecretKeySelector | None,
        Field(
            alias="passwordSecret",
            description=("PasswordSecret is the secret selector to the repository password"),
        ),
    ] = None
    username_secret: Annotated[
        v1.SecretKeySelector | None,
        Field(
            alias="usernameSecret",
            description=("UsernameSecret is the secret selector to the repository username"),
        ),
    ] = None


class ClientCertAuth(APIBaseModel):
    client_cert_secret: Annotated[v1.SecretKeySelector | None, Field(alias="clientCertSecret")] = None
    client_key_secret: Annotated[v1.SecretKeySelector | None, Field(alias="clientKeySecret")] = None


class GCSArtifact(APIBaseModel):
    bucket: Annotated[str | None, Field(description="Bucket is the name of the bucket")] = None
    key: Annotated[
        str,
        Field(description="Key is the path in the bucket where the artifact resides"),
    ]
    service_account_key_secret: Annotated[
        v1.SecretKeySelector | None,
        Field(
            alias="serviceAccountKeySecret",
            description=("ServiceAccountKeySecret is the secret selector to the bucket's service account key"),
        ),
    ] = None


class GCSArtifactRepository(APIBaseModel):
    bucket: Annotated[str | None, Field(description="Bucket is the name of the bucket")] = None
    key_format: Annotated[
        str | None,
        Field(
            alias="keyFormat",
            description=("KeyFormat defines the format of how to store keys and can reference workflow variables."),
        ),
    ] = None
    service_account_key_secret: Annotated[
        v1.SecretKeySelector | None,
        Field(
            alias="serviceAccountKeySecret",
            description=("ServiceAccountKeySecret is the secret selector to the bucket's service account key"),
        ),
    ] = None


class GitArtifact(APIBaseModel):
    branch: Annotated[
        str | None,
        Field(description="Branch is the branch to fetch when `SingleBranch` is enabled"),
    ] = None
    depth: Annotated[
        int | None,
        Field(
            description=(
                "Depth specifies clones/fetches should be shallow and include the given"
                " number of commits from the branch tip"
            )
        ),
    ] = None
    disable_submodules: Annotated[
        bool | None,
        Field(
            alias="disableSubmodules",
            description="DisableSubmodules disables submodules during git clone",
        ),
    ] = None
    fetch: Annotated[
        list[str] | None,
        Field(description=("Fetch specifies a number of refs that should be fetched before checkout")),
    ] = None
    insecure_ignore_host_key: Annotated[
        bool | None,
        Field(
            alias="insecureIgnoreHostKey",
            description=("InsecureIgnoreHostKey disables SSH strict host key checking during git clone"),
        ),
    ] = None
    insecure_skip_tls: Annotated[
        bool | None,
        Field(
            alias="insecureSkipTLS",
            description=(
                "InsecureSkipTLS disables server certificate verification resulting in insecure HTTPS connections"
            ),
        ),
    ] = None
    password_secret: Annotated[
        v1.SecretKeySelector | None,
        Field(
            alias="passwordSecret",
            description=("PasswordSecret is the secret selector to the repository password"),
        ),
    ] = None
    repo: Annotated[str, Field(description="Repo is the git repository")]
    revision: Annotated[
        str | None,
        Field(description="Revision is the git commit, tag, branch to checkout"),
    ] = None
    single_branch: Annotated[
        bool | None,
        Field(
            alias="singleBranch",
            description=("SingleBranch enables single branch clone, using the `branch` parameter"),
        ),
    ] = None
    ssh_private_key_secret: Annotated[
        v1.SecretKeySelector | None,
        Field(
            alias="sshPrivateKeySecret",
            description=("SSHPrivateKeySecret is the secret selector to the repository ssh private key"),
        ),
    ] = None
    username_secret: Annotated[
        v1.SecretKeySelector | None,
        Field(
            alias="usernameSecret",
            description=("UsernameSecret is the secret selector to the repository username"),
        ),
    ] = None


class HTTPHeaderSource(APIBaseModel):
    secret_key_ref: Annotated[v1.SecretKeySelector | None, Field(alias="secretKeyRef")] = None


class OAuth2Auth(APIBaseModel):
    client_id_secret: Annotated[v1.SecretKeySelector | None, Field(alias="clientIDSecret")] = None
    client_secret_secret: Annotated[v1.SecretKeySelector | None, Field(alias="clientSecretSecret")] = None
    endpoint_params: Annotated[list[OAuth2EndpointParam] | None, Field(alias="endpointParams")] = None
    scopes: list[str] | None = None
    token_url_secret: Annotated[v1.SecretKeySelector | None, Field(alias="tokenURLSecret")] = None


class S3EncryptionOptions(APIBaseModel):
    enable_encryption: Annotated[
        bool | None,
        Field(
            alias="enableEncryption",
            description=(
                "EnableEncryption tells the driver to encrypt objects if set to true."
                " If kmsKeyId and serverSideCustomerKeySecret are not set, SSE-S3 will"
                " be used"
            ),
        ),
    ] = None
    kms_encryption_context: Annotated[
        str | None,
        Field(
            alias="kmsEncryptionContext",
            description=(
                "KmsEncryptionContext is a json blob that contains an encryption"
                " context. See"
                " https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#encrypt_context"
                " for more information"
            ),
        ),
    ] = None
    kms_key_id: Annotated[
        str | None,
        Field(
            alias="kmsKeyId",
            description=("KMSKeyId tells the driver to encrypt the object using the specified KMS Key."),
        ),
    ] = None
    server_side_customer_key_secret: Annotated[
        v1.SecretKeySelector | None,
        Field(
            alias="serverSideCustomerKeySecret",
            description=(
                "ServerSideCustomerKeySecret tells the driver to encrypt the output"
                " artifacts using SSE-C with the specified secret."
            ),
        ),
    ] = None


class Cache(APIBaseModel):
    config_map: Annotated[
        v1.ConfigMapKeySelector,
        Field(alias="configMap", description="ConfigMap sets a ConfigMap-based cache"),
    ]


class HDFSArtifact(APIBaseModel):
    addresses: Annotated[
        list[str] | None,
        Field(description="Addresses is accessible addresses of HDFS name nodes"),
    ] = None
    data_transfer_protection: Annotated[
        str | None,
        Field(
            alias="dataTransferProtection",
            description=(
                "DataTransferProtection is the protection level for HDFS data transfer."
                " It corresponds to the dfs.data.transfer.protection configuration in"
                " HDFS."
            ),
        ),
    ] = None
    force: Annotated[bool | None, Field(description="Force copies a file forcibly even if it exists")] = None
    hdfs_user: Annotated[
        str | None,
        Field(
            alias="hdfsUser",
            description=(
                "HDFSUser is the user to access HDFS file system. It is ignored if either ccache or keytab is used."
            ),
        ),
    ] = None
    krb_c_cache_secret: Annotated[
        v1.SecretKeySelector | None,
        Field(
            alias="krbCCacheSecret",
            description=(
                "KrbCCacheSecret is the secret selector for Kerberos ccache Either"
                " ccache or keytab can be set to use Kerberos."
            ),
        ),
    ] = None
    krb_config_config_map: Annotated[
        v1.ConfigMapKeySelector | None,
        Field(
            alias="krbConfigConfigMap",
            description=(
                "KrbConfig is the configmap selector for Kerberos config as string It"
                " must be set if either ccache or keytab is used."
            ),
        ),
    ] = None
    krb_keytab_secret: Annotated[
        v1.SecretKeySelector | None,
        Field(
            alias="krbKeytabSecret",
            description=(
                "KrbKeytabSecret is the secret selector for Kerberos keytab Either"
                " ccache or keytab can be set to use Kerberos."
            ),
        ),
    ] = None
    krb_realm: Annotated[
        str | None,
        Field(
            alias="krbRealm",
            description=("KrbRealm is the Kerberos realm used with Kerberos keytab It must be set if keytab is used."),
        ),
    ] = None
    krb_service_principal_name: Annotated[
        str | None,
        Field(
            alias="krbServicePrincipalName",
            description=(
                "KrbServicePrincipalName is the principal name of Kerberos service It"
                " must be set if either ccache or keytab is used."
            ),
        ),
    ] = None
    krb_username: Annotated[
        str | None,
        Field(
            alias="krbUsername",
            description=(
                "KrbUsername is the Kerberos username used with Kerberos keytab It must be set if keytab is used."
            ),
        ),
    ] = None
    path: Annotated[str, Field(description="Path is a file path in HDFS")]


class HDFSArtifactRepository(APIBaseModel):
    addresses: Annotated[
        list[str] | None,
        Field(description="Addresses is accessible addresses of HDFS name nodes"),
    ] = None
    data_transfer_protection: Annotated[
        str | None,
        Field(
            alias="dataTransferProtection",
            description=(
                "DataTransferProtection is the protection level for HDFS data transfer."
                " It corresponds to the dfs.data.transfer.protection configuration in"
                " HDFS."
            ),
        ),
    ] = None
    force: Annotated[bool | None, Field(description="Force copies a file forcibly even if it exists")] = None
    hdfs_user: Annotated[
        str | None,
        Field(
            alias="hdfsUser",
            description=(
                "HDFSUser is the user to access HDFS file system. It is ignored if either ccache or keytab is used."
            ),
        ),
    ] = None
    krb_c_cache_secret: Annotated[
        v1.SecretKeySelector | None,
        Field(
            alias="krbCCacheSecret",
            description=(
                "KrbCCacheSecret is the secret selector for Kerberos ccache Either"
                " ccache or keytab can be set to use Kerberos."
            ),
        ),
    ] = None
    krb_config_config_map: Annotated[
        v1.ConfigMapKeySelector | None,
        Field(
            alias="krbConfigConfigMap",
            description=(
                "KrbConfig is the configmap selector for Kerberos config as string It"
                " must be set if either ccache or keytab is used."
            ),
        ),
    ] = None
    krb_keytab_secret: Annotated[
        v1.SecretKeySelector | None,
        Field(
            alias="krbKeytabSecret",
            description=(
                "KrbKeytabSecret is the secret selector for Kerberos keytab Either"
                " ccache or keytab can be set to use Kerberos."
            ),
        ),
    ] = None
    krb_realm: Annotated[
        str | None,
        Field(
            alias="krbRealm",
            description=("KrbRealm is the Kerberos realm used with Kerberos keytab It must be set if keytab is used."),
        ),
    ] = None
    krb_service_principal_name: Annotated[
        str | None,
        Field(
            alias="krbServicePrincipalName",
            description=(
                "KrbServicePrincipalName is the principal name of Kerberos service It"
                " must be set if either ccache or keytab is used."
            ),
        ),
    ] = None
    krb_username: Annotated[
        str | None,
        Field(
            alias="krbUsername",
            description=(
                "KrbUsername is the Kerberos username used with Kerberos keytab It must be set if keytab is used."
            ),
        ),
    ] = None
    path_format: Annotated[
        str | None,
        Field(
            alias="pathFormat",
            description=("PathFormat is defines the format of path to store a file. Can reference workflow variables"),
        ),
    ] = None


class ArchiveStrategy(APIBaseModel):
    none: NoneStrategy | None = None
    tar: TarStrategy | None = None
    zip: ZipStrategy | None = None


class ArtifactGC(APIBaseModel):
    pod_metadata: Annotated[
        Metadata | None,
        Field(
            alias="podMetadata",
            description=(
                "PodMetadata is an optional field for specifying the Labels and"
                " Annotations that should be assigned to the Pod doing the deletion"
            ),
        ),
    ] = None
    service_account_name: Annotated[
        str | None,
        Field(
            alias="serviceAccountName",
            description=(
                "ServiceAccountName is an optional field for specifying the Service"
                " Account that should be assigned to the Pod doing the deletion"
            ),
        ),
    ] = None
    strategy: Annotated[str | None, Field(description="Strategy is the strategy to use.")] = None


class WorkflowLevelArtifactGC(APIBaseModel):
    force_finalizer_removal: Annotated[
        bool | None,
        Field(
            alias="forceFinalizerRemoval",
            description=(
                "ForceFinalizerRemoval: if set to true, the finalizer will be removed"
                " in the case that Artifact GC fails"
            ),
        ),
    ] = None
    pod_metadata: Annotated[
        Metadata | None,
        Field(
            alias="podMetadata",
            description=(
                "PodMetadata is an optional field for specifying the Labels and"
                " Annotations that should be assigned to the Pod doing the deletion"
            ),
        ),
    ] = None
    pod_spec_patch: Annotated[
        str | None,
        Field(
            alias="podSpecPatch",
            description=("PodSpecPatch holds strategic merge patch to apply against the artgc pod spec."),
        ),
    ] = None
    service_account_name: Annotated[
        str | None,
        Field(
            alias="serviceAccountName",
            description=(
                "ServiceAccountName is an optional field for specifying the Service"
                " Account that should be assigned to the Pod doing the deletion"
            ),
        ),
    ] = None
    strategy: Annotated[str | None, Field(description="Strategy is the strategy to use.")] = None


class Backoff(APIBaseModel):
    cap: Annotated[
        str | None,
        Field(
            description=(
                "Cap is a limit on revised values of the duration parameter. If a"
                " multiplication by the factor parameter would make the duration exceed"
                " the cap then the duration is set to the cap"
            )
        ),
    ] = None
    duration: Annotated[
        str | None,
        Field(
            description=(
                "Duration is the amount to back off. Default unit is seconds, but could"
                ' also be a duration (e.g. "2m", "1h")'
            )
        ),
    ] = None
    factor: Annotated[
        intstr.IntOrString | None,
        Field(description=("Factor is a factor to multiply the base duration after each failed retry")),
    ] = None
    max_duration: Annotated[
        str | None,
        Field(
            alias="maxDuration",
            description=(
                "MaxDuration is the maximum amount of time allowed for a workflow in"
                " the backoff strategy. It is important to note that if the workflow"
                " template includes activeDeadlineSeconds, the pod's deadline is"
                " initially set with activeDeadlineSeconds. However, when the workflow"
                " fails, the pod's deadline is then overridden by maxDuration. This"
                " ensures that the workflow does not exceed the specified maximum"
                " duration when retries are involved."
            ),
        ),
    ] = None


class ContainerSetRetryStrategy(APIBaseModel):
    duration: Annotated[
        str | None,
        Field(
            description=(
                'Duration is the time between each retry, examples values are "300ms",'
                ' "1s" or "5m". Valid time units are "ns", "us" (or "Âµs"), "ms", "s",'
                ' "m", "h".'
            )
        ),
    ] = None
    retries: Annotated[
        intstr.IntOrString,
        Field(
            description=(
                "Retries is the maximum number of retry attempts for each container. It"
                " does not include the first, original attempt; the maximum number of"
                " total attempts will be `retries + 1`."
            )
        ),
    ]


class Sequence(APIBaseModel):
    count: Annotated[
        intstr.IntOrString | None,
        Field(description=("Count is number of elements in the sequence (default: 0). Not to be used with end")),
    ] = None
    end: Annotated[
        intstr.IntOrString | None,
        Field(description=("Number at which to end the sequence (default: 0). Not to be used with Count")),
    ] = None
    format: Annotated[
        str | None,
        Field(description=("Format is a printf format string to format the value in the sequence")),
    ] = None
    start: Annotated[
        intstr.IntOrString | None,
        Field(description="Number at which to start the sequence (default: 0)"),
    ] = None


class Prometheus(APIBaseModel):
    counter: Annotated[Counter | None, Field(description="Counter is a counter metric")] = None
    gauge: Annotated[Gauge | None, Field(description="Gauge is a gauge metric")] = None
    help: Annotated[str, Field(description="Help is a string that describes the metric")]
    histogram: Annotated[Histogram | None, Field(description="Histogram is a histogram metric")] = None
    labels: Annotated[list[MetricLabel] | None, Field(description="Labels is a list of metric labels")] = None
    name: Annotated[str, Field(description="Name is the name of the metric")]
    when: Annotated[
        str | None,
        Field(description=("When is a conditional statement that decides when to emit the metric")),
    ] = None


class OSSArtifact(APIBaseModel):
    access_key_secret: Annotated[
        v1.SecretKeySelector | None,
        Field(
            alias="accessKeySecret",
            description=("AccessKeySecret is the secret selector to the bucket's access key"),
        ),
    ] = None
    bucket: Annotated[str | None, Field(description="Bucket is the name of the bucket")] = None
    create_bucket_if_not_present: Annotated[
        bool | None,
        Field(
            alias="createBucketIfNotPresent",
            description=(
                "CreateBucketIfNotPresent tells the driver to attempt to create the OSS"
                " bucket for output artifacts, if it doesn't exist"
            ),
        ),
    ] = None
    endpoint: Annotated[str | None, Field(description="Endpoint is the hostname of the bucket endpoint")] = None
    key: Annotated[
        str,
        Field(description="Key is the path in the bucket where the artifact resides"),
    ]
    lifecycle_rule: Annotated[
        OSSLifecycleRule | None,
        Field(
            alias="lifecycleRule",
            description="LifecycleRule specifies how to manage bucket's lifecycle",
        ),
    ] = None
    secret_key_secret: Annotated[
        v1.SecretKeySelector | None,
        Field(
            alias="secretKeySecret",
            description=("SecretKeySecret is the secret selector to the bucket's secret key"),
        ),
    ] = None
    security_token: Annotated[
        str | None,
        Field(
            alias="securityToken",
            description=(
                "SecurityToken is the user's temporary security token. For more"
                " details, check out:"
                " https://www.alibabacloud.com/help/doc-detail/100624.htm"
            ),
        ),
    ] = None
    use_sdk_creds: Annotated[
        bool | None,
        Field(
            alias="useSDKCreds",
            description=("UseSDKCreds tells the driver to figure out credentials based on sdk defaults."),
        ),
    ] = None


class OSSArtifactRepository(APIBaseModel):
    access_key_secret: Annotated[
        v1.SecretKeySelector | None,
        Field(
            alias="accessKeySecret",
            description=("AccessKeySecret is the secret selector to the bucket's access key"),
        ),
    ] = None
    bucket: Annotated[str | None, Field(description="Bucket is the name of the bucket")] = None
    create_bucket_if_not_present: Annotated[
        bool | None,
        Field(
            alias="createBucketIfNotPresent",
            description=(
                "CreateBucketIfNotPresent tells the driver to attempt to create the OSS"
                " bucket for output artifacts, if it doesn't exist"
            ),
        ),
    ] = None
    endpoint: Annotated[str | None, Field(description="Endpoint is the hostname of the bucket endpoint")] = None
    key_format: Annotated[
        str | None,
        Field(
            alias="keyFormat",
            description=("KeyFormat defines the format of how to store keys and can reference workflow variables."),
        ),
    ] = None
    lifecycle_rule: Annotated[
        OSSLifecycleRule | None,
        Field(
            alias="lifecycleRule",
            description="LifecycleRule specifies how to manage bucket's lifecycle",
        ),
    ] = None
    secret_key_secret: Annotated[
        v1.SecretKeySelector | None,
        Field(
            alias="secretKeySecret",
            description=("SecretKeySecret is the secret selector to the bucket's secret key"),
        ),
    ] = None
    security_token: Annotated[
        str | None,
        Field(
            alias="securityToken",
            description=(
                "SecurityToken is the user's temporary security token. For more"
                " details, check out:"
                " https://www.alibabacloud.com/help/doc-detail/100624.htm"
            ),
        ),
    ] = None
    use_sdk_creds: Annotated[
        bool | None,
        Field(
            alias="useSDKCreds",
            description=("UseSDKCreds tells the driver to figure out credentials based on sdk defaults."),
        ),
    ] = None


class RetryAffinity(APIBaseModel):
    node_anti_affinity: Annotated[RetryNodeAntiAffinity | None, Field(alias="nodeAntiAffinity")] = None


class SemaphoreRef(APIBaseModel):
    config_map_key_ref: Annotated[
        v1.ConfigMapKeySelector | None,
        Field(
            alias="configMapKeyRef",
            description=("ConfigMapKeyRef is a configmap selector for Semaphore configuration"),
        ),
    ] = None
    database: Annotated[
        SyncDatabaseRef | None,
        Field(description=("SyncDatabaseRef is a database reference for Semaphore configuration")),
    ] = None
    namespace: Annotated[
        str | None,
        Field(description=("Namespace is the namespace of the configmap, default: [namespace of workflow]")),
    ] = None


class SynchronizationStatus(APIBaseModel):
    mutex: Annotated[
        MutexStatus | None,
        Field(description="Mutex stores this workflow's mutex holder details"),
    ] = None
    semaphore: Annotated[
        SemaphoreStatus | None,
        Field(description="Semaphore stores this workflow's Semaphore holder details"),
    ] = None


class SubmitOpts(APIBaseModel):
    annotations: Annotated[str | None, Field(description="Annotations adds to metadata.labels")] = None
    dry_run: Annotated[
        bool | None,
        Field(
            alias="dryRun",
            description=(
                "DryRun validates the workflow on the client-side without creating it."
                " This option is not supported in API"
            ),
        ),
    ] = None
    entry_point: Annotated[
        str | None,
        Field(alias="entryPoint", description="Entrypoint overrides spec.entrypoint"),
    ] = None
    generate_name: Annotated[
        str | None,
        Field(
            alias="generateName",
            description="GenerateName overrides metadata.generateName",
        ),
    ] = None
    labels: Annotated[str | None, Field(description="Labels adds to metadata.labels")] = None
    name: Annotated[str | None, Field(description="Name overrides metadata.name")] = None
    owner_reference: Annotated[
        v1_1.OwnerReference | None,
        Field(
            alias="ownerReference",
            description="OwnerReference creates a metadata.ownerReference",
        ),
    ] = None
    parameters: Annotated[
        list[str] | None,
        Field(description="Parameters passes input parameters to workflow"),
    ] = None
    pod_priority_class_name: Annotated[
        str | None,
        Field(
            alias="podPriorityClassName",
            description="Set the podPriorityClassName of the workflow",
        ),
    ] = None
    priority: Annotated[
        int | None,
        Field(
            description=(
                "Priority is used if controller is configured to process limited number"
                " of workflows in parallel, higher priority workflows are processed"
                " first."
            )
        ),
    ] = None
    server_dry_run: Annotated[
        bool | None,
        Field(
            alias="serverDryRun",
            description=("ServerDryRun validates the workflow on the server-side without creating it"),
        ),
    ] = None
    service_account: Annotated[
        str | None,
        Field(
            alias="serviceAccount",
            description=("ServiceAccount runs all pods in the workflow using specified ServiceAccount."),
        ),
    ] = None


class ValueFrom(APIBaseModel):
    config_map_key_ref: Annotated[
        v1.ConfigMapKeySelector | None,
        Field(
            alias="configMapKeyRef",
            description=("ConfigMapKeyRef is configmap selector for input parameter configuration"),
        ),
    ] = None
    default: Annotated[
        str | None,
        Field(
            description=(
                "Default specifies a value to be used if retrieving the value from the specified source fails"
            )
        ),
    ] = None
    event: Annotated[
        str | None,
        Field(
            description=(
                "Selector (https://github.com/expr-lang/expr) that is evaluated against"
                " the event to get the value of the parameter. E.g. `payload.message`"
            )
        ),
    ] = None
    expression: Annotated[
        str | None,
        Field(description=("Expression, if defined, is evaluated to specify the value for the parameter")),
    ] = None
    jq_filter: Annotated[
        str | None,
        Field(
            alias="jqFilter",
            description=("JQFilter expression against the resource object in resource templates"),
        ),
    ] = None
    json_path: Annotated[
        str | None,
        Field(
            alias="jsonPath",
            description=("JSONPath of a resource to retrieve an output parameter value from in resource templates"),
        ),
    ] = None
    parameter: Annotated[
        str | None,
        Field(
            description=(
                "Parameter reference to a step or dag task in which to retrieve an"
                " output parameter value from (e.g. '{{steps.mystep.outputs.myparam}}')"
            )
        ),
    ] = None
    path: Annotated[
        str | None,
        Field(description=("Path in the container to retrieve an output parameter value from in container templates")),
    ] = None
    supplied: Annotated[
        SuppliedValueFrom | None,
        Field(description=("Supplied value to be filled in directly, either through the CLI, API, etc.")),
    ] = None


class HTTPHeader(APIBaseModel):
    name: str
    value: str | None = None
    value_from: Annotated[HTTPHeaderSource | None, Field(alias="valueFrom")] = None


class HTTPAuth(APIBaseModel):
    basic_auth: Annotated[BasicAuth | None, Field(alias="basicAuth")] = None
    client_cert: Annotated[ClientCertAuth | None, Field(alias="clientCert")] = None
    oauth2: OAuth2Auth | None = None


class S3Artifact(APIBaseModel):
    access_key_secret: Annotated[
        v1.SecretKeySelector | None,
        Field(
            alias="accessKeySecret",
            description=("AccessKeySecret is the secret selector to the bucket's access key"),
        ),
    ] = None
    bucket: Annotated[str | None, Field(description="Bucket is the name of the bucket")] = None
    ca_secret: Annotated[
        v1.SecretKeySelector | None,
        Field(
            alias="caSecret",
            description=("CASecret specifies the secret that contains the CA, used to verify the TLS connection"),
        ),
    ] = None
    create_bucket_if_not_present: Annotated[
        CreateS3BucketOptions | None,
        Field(
            alias="createBucketIfNotPresent",
            description=(
                "CreateBucketIfNotPresent tells the driver to attempt to create the S3"
                " bucket for output artifacts, if it doesn't exist. Setting Enabled"
                " Encryption will apply either SSE-S3 to the bucket if KmsKeyId is not"
                " set or SSE-KMS if it is."
            ),
        ),
    ] = None
    encryption_options: Annotated[S3EncryptionOptions | None, Field(alias="encryptionOptions")] = None
    endpoint: Annotated[str | None, Field(description="Endpoint is the hostname of the bucket endpoint")] = None
    insecure: Annotated[bool | None, Field(description="Insecure will connect to the service with TLS")] = None
    key: Annotated[
        str | None,
        Field(description="Key is the key in the bucket where the artifact resides"),
    ] = None
    region: Annotated[str | None, Field(description="Region contains the optional bucket region")] = None
    role_arn: Annotated[
        str | None,
        Field(
            alias="roleARN",
            description=("RoleARN is the Amazon Resource Name (ARN) of the role to assume."),
        ),
    ] = None
    secret_key_secret: Annotated[
        v1.SecretKeySelector | None,
        Field(
            alias="secretKeySecret",
            description=("SecretKeySecret is the secret selector to the bucket's secret key"),
        ),
    ] = None
    session_token_secret: Annotated[
        v1.SecretKeySelector | None,
        Field(
            alias="sessionTokenSecret",
            description=(
                "SessionTokenSecret is used for ephemeral credentials like an IAM assume role or S3 access grant"
            ),
        ),
    ] = None
    use_sdk_creds: Annotated[
        bool | None,
        Field(
            alias="useSDKCreds",
            description=("UseSDKCreds tells the driver to figure out credentials based on sdk defaults."),
        ),
    ] = None


class S3ArtifactRepository(APIBaseModel):
    access_key_secret: Annotated[
        v1.SecretKeySelector | None,
        Field(
            alias="accessKeySecret",
            description=("AccessKeySecret is the secret selector to the bucket's access key"),
        ),
    ] = None
    bucket: Annotated[str | None, Field(description="Bucket is the name of the bucket")] = None
    ca_secret: Annotated[
        v1.SecretKeySelector | None,
        Field(
            alias="caSecret",
            description=("CASecret specifies the secret that contains the CA, used to verify the TLS connection"),
        ),
    ] = None
    create_bucket_if_not_present: Annotated[
        CreateS3BucketOptions | None,
        Field(
            alias="createBucketIfNotPresent",
            description=(
                "CreateBucketIfNotPresent tells the driver to attempt to create the S3"
                " bucket for output artifacts, if it doesn't exist. Setting Enabled"
                " Encryption will apply either SSE-S3 to the bucket if KmsKeyId is not"
                " set or SSE-KMS if it is."
            ),
        ),
    ] = None
    encryption_options: Annotated[S3EncryptionOptions | None, Field(alias="encryptionOptions")] = None
    endpoint: Annotated[str | None, Field(description="Endpoint is the hostname of the bucket endpoint")] = None
    insecure: Annotated[bool | None, Field(description="Insecure will connect to the service with TLS")] = None
    key_format: Annotated[
        str | None,
        Field(
            alias="keyFormat",
            description=("KeyFormat defines the format of how to store keys and can reference workflow variables."),
        ),
    ] = None
    key_prefix: Annotated[
        str | None,
        Field(
            alias="keyPrefix",
            description=(
                "KeyPrefix is prefix used as part of the bucket key in which the"
                " controller will store artifacts. DEPRECATED. Use KeyFormat instead"
            ),
        ),
    ] = None
    region: Annotated[str | None, Field(description="Region contains the optional bucket region")] = None
    role_arn: Annotated[
        str | None,
        Field(
            alias="roleARN",
            description=("RoleARN is the Amazon Resource Name (ARN) of the role to assume."),
        ),
    ] = None
    secret_key_secret: Annotated[
        v1.SecretKeySelector | None,
        Field(
            alias="secretKeySecret",
            description=("SecretKeySecret is the secret selector to the bucket's secret key"),
        ),
    ] = None
    session_token_secret: Annotated[
        v1.SecretKeySelector | None,
        Field(
            alias="sessionTokenSecret",
            description=(
                "SessionTokenSecret is used for ephemeral credentials like an IAM assume role or S3 access grant"
            ),
        ),
    ] = None
    use_sdk_creds: Annotated[
        bool | None,
        Field(
            alias="useSDKCreds",
            description=("UseSDKCreds tells the driver to figure out credentials based on sdk defaults."),
        ),
    ] = None


class Memoize(APIBaseModel):
    cache: Annotated[Cache, Field(description="Cache sets and configures the kind of cache")]
    key: Annotated[str, Field(description="Key is the key to use as the caching key")]
    max_age: Annotated[
        str,
        Field(
            alias="maxAge",
            description=(
                'MaxAge is the maximum age (e.g. "180s", "24h") of an entry that is'
                " still considered valid. If an entry is older than the MaxAge, it will"
                " be ignored."
            ),
        ),
    ]


class RetryStrategy(APIBaseModel):
    affinity: Annotated[
        RetryAffinity | None,
        Field(description="Affinity prevents running workflow's step on the same host"),
    ] = None
    backoff: Annotated[Backoff | None, Field(description="Backoff is a backoff strategy")] = None
    expression: Annotated[
        str | None,
        Field(
            description=(
                "Expression is a condition expression for when a node will be retried."
                " If it evaluates to false, the node will not be retried and the retry"
                " strategy will be ignored"
            )
        ),
    ] = None
    limit: Annotated[
        intstr.IntOrString | None,
        Field(
            description=(
                "Limit is the maximum number of retry attempts when retrying a"
                " container. It does not include the original container; the maximum"
                " number of total attempts will be `limit + 1`."
            )
        ),
    ] = None
    retry_policy: Annotated[
        str | None,
        Field(
            alias="retryPolicy",
            description=("RetryPolicy is a policy of NodePhase statuses that will be retried"),
        ),
    ] = None


class Synchronization(APIBaseModel):
    mutex: Annotated[
        Mutex | None,
        Field(description=("Mutex holds the Mutex lock details - deprecated, use mutexes instead")),
    ] = None
    mutexes: Annotated[
        list[Mutex] | None,
        Field(description="v3.6 and after: Mutexes holds the list of Mutex lock details"),
    ] = None
    semaphore: Annotated[
        SemaphoreRef | None,
        Field(description=("Semaphore holds the Semaphore configuration - deprecated, use semaphores instead")),
    ] = None
    semaphores: Annotated[
        list[SemaphoreRef] | None,
        Field(description=("v3.6 and after: Semaphores holds the list of Semaphores configuration")),
    ] = None


class WorkflowSubmitRequest(APIBaseModel):
    namespace: str | None = None
    resource_kind: Annotated[str | None, Field(alias="resourceKind")] = None
    resource_name: Annotated[str | None, Field(alias="resourceName")] = None
    submit_options: Annotated[SubmitOpts | None, Field(alias="submitOptions")] = None


class Parameter(APIBaseModel):
    default: Annotated[
        str | None,
        Field(description=("Default is the default value to use for an input parameter if a value was not supplied")),
    ] = None
    description: Annotated[str | None, Field(description="Description is the parameter description")] = None
    enum: Annotated[
        list[str] | None,
        Field(
            description=("Enum holds a list of string values to choose from, for the actual value of the parameter")
        ),
    ] = None
    global_name: Annotated[
        str | None,
        Field(
            alias="globalName",
            description=(
                "GlobalName exports an output parameter to the global scope, making it"
                " available as"
                " '{{io.argoproj.workflow.v1alpha1.outputs.parameters.XXXX}} and in"
                " workflow.status.outputs.parameters"
            ),
        ),
    ] = None
    name: Annotated[str, Field(description="Name is the parameter name")]
    value: Annotated[
        str | None,
        Field(
            description=(
                "Value is the literal value to use for the parameter. If specified in"
                " the context of an input parameter, any passed values take precedence"
                " over the specified value"
            )
        ),
    ] = None
    value_from: Annotated[
        ValueFrom | None,
        Field(
            alias="valueFrom",
            description="ValueFrom is the source for the output parameter's value",
        ),
    ] = None


class HTTPArtifact(APIBaseModel):
    auth: Annotated[
        HTTPAuth | None,
        Field(description="Auth contains information for client authentication"),
    ] = None
    headers: Annotated[
        list[Header] | None,
        Field(description=("Headers are an optional list of headers to send with HTTP requests for artifacts")),
    ] = None
    url: Annotated[str, Field(description="URL of the artifact")]


class ArtifactRepository(APIBaseModel):
    archive_logs: Annotated[
        bool | None,
        Field(alias="archiveLogs", description="ArchiveLogs enables log archiving"),
    ] = None
    artifactory: Annotated[
        ArtifactoryArtifactRepository | None,
        Field(description="Artifactory stores artifacts to JFrog Artifactory"),
    ] = None
    azure: Annotated[
        AzureArtifactRepository | None,
        Field(description="Azure stores artifact in an Azure Storage account"),
    ] = None
    gcs: Annotated[
        GCSArtifactRepository | None,
        Field(description="GCS stores artifact in a GCS object store"),
    ] = None
    hdfs: Annotated[
        HDFSArtifactRepository | None,
        Field(description="HDFS stores artifacts in HDFS"),
    ] = None
    oss: Annotated[
        OSSArtifactRepository | None,
        Field(description="OSS stores artifact in a OSS-compliant object store"),
    ] = None
    s3: Annotated[
        S3ArtifactRepository | None,
        Field(description="S3 stores artifact in a S3-compliant object store"),
    ] = None


class Artifact(APIBaseModel):
    archive: Annotated[
        ArchiveStrategy | None,
        Field(description=("Archive controls how the artifact will be saved to the artifact repository.")),
    ] = None
    archive_logs: Annotated[
        bool | None,
        Field(
            alias="archiveLogs",
            description=("ArchiveLogs indicates if the container logs should be archived"),
        ),
    ] = None
    artifact_gc: Annotated[
        ArtifactGC | None,
        Field(
            alias="artifactGC",
            description=(
                "ArtifactGC describes the strategy to use when to deleting an artifact"
                " from completed or deleted workflows"
            ),
        ),
    ] = None
    artifactory: Annotated[
        ArtifactoryArtifact | None,
        Field(description="Artifactory contains artifactory artifact location details"),
    ] = None
    azure: Annotated[
        AzureArtifact | None,
        Field(description="Azure contains Azure Storage artifact location details"),
    ] = None
    deleted: Annotated[bool | None, Field(description="Has this been deleted?")] = None
    from_: Annotated[
        str | None,
        Field(
            alias="from",
            description=("From allows an artifact to reference an artifact from a previous step"),
        ),
    ] = None
    from_expression: Annotated[
        str | None,
        Field(
            alias="fromExpression",
            description=("FromExpression, if defined, is evaluated to specify the value for the artifact"),
        ),
    ] = None
    gcs: Annotated[
        GCSArtifact | None,
        Field(description="GCS contains GCS artifact location details"),
    ] = None
    git: Annotated[
        GitArtifact | None,
        Field(description="Git contains git artifact location details"),
    ] = None
    global_name: Annotated[
        str | None,
        Field(
            alias="globalName",
            description=(
                "GlobalName exports an output artifact to the global scope, making it"
                " available as"
                " '{{io.argoproj.workflow.v1alpha1.outputs.artifacts.XXXX}} and in"
                " workflow.status.outputs.artifacts"
            ),
        ),
    ] = None
    hdfs: Annotated[
        HDFSArtifact | None,
        Field(description="HDFS contains HDFS artifact location details"),
    ] = None
    http: Annotated[
        HTTPArtifact | None,
        Field(description="HTTP contains HTTP artifact location details"),
    ] = None
    mode: Annotated[
        int | None,
        Field(
            description=(
                "mode bits to use on this file, must be a value between 0 and 0777 set when loading input artifacts."
            )
        ),
    ] = None
    name: Annotated[
        str,
        Field(description=("name of the artifact. must be unique within a template's inputs/outputs.")),
    ]
    optional: Annotated[
        bool | None,
        Field(description=("Make Artifacts optional, if Artifacts doesn't generate or exist")),
    ] = None
    oss: Annotated[
        OSSArtifact | None,
        Field(description="OSS contains OSS artifact location details"),
    ] = None
    path: Annotated[str | None, Field(description="Path is the container path to the artifact")] = None
    raw: Annotated[
        RawArtifact | None,
        Field(description="Raw contains raw artifact location details"),
    ] = None
    recurse_mode: Annotated[
        bool | None,
        Field(
            alias="recurseMode",
            description=("If mode is set, apply the permission recursively into the artifact if it is a folder"),
        ),
    ] = None
    s3: Annotated[S3Artifact | None, Field(description="S3 contains S3 artifact location details")] = None
    sub_path: Annotated[
        str | None,
        Field(
            alias="subPath",
            description=("SubPath allows an artifact to be sourced from a subpath within the specified source"),
        ),
    ] = None


class ArtifactLocation(APIBaseModel):
    archive_logs: Annotated[
        bool | None,
        Field(
            alias="archiveLogs",
            description=("ArchiveLogs indicates if the container logs should be archived"),
        ),
    ] = None
    artifactory: Annotated[
        ArtifactoryArtifact | None,
        Field(description="Artifactory contains artifactory artifact location details"),
    ] = None
    azure: Annotated[
        AzureArtifact | None,
        Field(description="Azure contains Azure Storage artifact location details"),
    ] = None
    gcs: Annotated[
        GCSArtifact | None,
        Field(description="GCS contains GCS artifact location details"),
    ] = None
    git: Annotated[
        GitArtifact | None,
        Field(description="Git contains git artifact location details"),
    ] = None
    hdfs: Annotated[
        HDFSArtifact | None,
        Field(description="HDFS contains HDFS artifact location details"),
    ] = None
    http: Annotated[
        HTTPArtifact | None,
        Field(description="HTTP contains HTTP artifact location details"),
    ] = None
    oss: Annotated[
        OSSArtifact | None,
        Field(description="OSS contains OSS artifact location details"),
    ] = None
    raw: Annotated[
        RawArtifact | None,
        Field(description="Raw contains raw artifact location details"),
    ] = None
    s3: Annotated[S3Artifact | None, Field(description="S3 contains S3 artifact location details")] = None


class ArtifactPaths(APIBaseModel):
    archive: Annotated[
        ArchiveStrategy | None,
        Field(description=("Archive controls how the artifact will be saved to the artifact repository.")),
    ] = None
    archive_logs: Annotated[
        bool | None,
        Field(
            alias="archiveLogs",
            description=("ArchiveLogs indicates if the container logs should be archived"),
        ),
    ] = None
    artifact_gc: Annotated[
        ArtifactGC | None,
        Field(
            alias="artifactGC",
            description=(
                "ArtifactGC describes the strategy to use when to deleting an artifact"
                " from completed or deleted workflows"
            ),
        ),
    ] = None
    artifactory: Annotated[
        ArtifactoryArtifact | None,
        Field(description="Artifactory contains artifactory artifact location details"),
    ] = None
    azure: Annotated[
        AzureArtifact | None,
        Field(description="Azure contains Azure Storage artifact location details"),
    ] = None
    deleted: Annotated[bool | None, Field(description="Has this been deleted?")] = None
    from_: Annotated[
        str | None,
        Field(
            alias="from",
            description=("From allows an artifact to reference an artifact from a previous step"),
        ),
    ] = None
    from_expression: Annotated[
        str | None,
        Field(
            alias="fromExpression",
            description=("FromExpression, if defined, is evaluated to specify the value for the artifact"),
        ),
    ] = None
    gcs: Annotated[
        GCSArtifact | None,
        Field(description="GCS contains GCS artifact location details"),
    ] = None
    git: Annotated[
        GitArtifact | None,
        Field(description="Git contains git artifact location details"),
    ] = None
    global_name: Annotated[
        str | None,
        Field(
            alias="globalName",
            description=(
                "GlobalName exports an output artifact to the global scope, making it"
                " available as"
                " '{{io.argoproj.workflow.v1alpha1.outputs.artifacts.XXXX}} and in"
                " workflow.status.outputs.artifacts"
            ),
        ),
    ] = None
    hdfs: Annotated[
        HDFSArtifact | None,
        Field(description="HDFS contains HDFS artifact location details"),
    ] = None
    http: Annotated[
        HTTPArtifact | None,
        Field(description="HTTP contains HTTP artifact location details"),
    ] = None
    mode: Annotated[
        int | None,
        Field(
            description=(
                "mode bits to use on this file, must be a value between 0 and 0777 set when loading input artifacts."
            )
        ),
    ] = None
    name: Annotated[
        str,
        Field(description=("name of the artifact. must be unique within a template's inputs/outputs.")),
    ]
    optional: Annotated[
        bool | None,
        Field(description=("Make Artifacts optional, if Artifacts doesn't generate or exist")),
    ] = None
    oss: Annotated[
        OSSArtifact | None,
        Field(description="OSS contains OSS artifact location details"),
    ] = None
    path: Annotated[str | None, Field(description="Path is the container path to the artifact")] = None
    raw: Annotated[
        RawArtifact | None,
        Field(description="Raw contains raw artifact location details"),
    ] = None
    recurse_mode: Annotated[
        bool | None,
        Field(
            alias="recurseMode",
            description=("If mode is set, apply the permission recursively into the artifact if it is a folder"),
        ),
    ] = None
    s3: Annotated[S3Artifact | None, Field(description="S3 contains S3 artifact location details")] = None
    sub_path: Annotated[
        str | None,
        Field(
            alias="subPath",
            description=("SubPath allows an artifact to be sourced from a subpath within the specified source"),
        ),
    ] = None


class ArtifactRepositoryRefStatus(APIBaseModel):
    artifact_repository: Annotated[
        ArtifactRepository | None,
        Field(
            alias="artifactRepository",
            description=("The repository the workflow will use. This maybe empty before v3.1."),
        ),
    ] = None
    config_map: Annotated[
        str | None,
        Field(
            alias="configMap",
            description=('The name of the config map. Defaults to "artifact-repositories".'),
        ),
    ] = None
    default: Annotated[
        bool | None,
        Field(description=("If this ref represents the default artifact repository, rather than a config map.")),
    ] = None
    key: Annotated[
        str | None,
        Field(
            description=(
                "The config map key. Defaults to the value of the"
                ' "workflows.argoproj.io/default-artifact-repository" annotation.'
            )
        ),
    ] = None
    namespace: Annotated[
        str | None,
        Field(
            description=(
                "The namespace of the config map. Defaults to the workflow's namespace,"
                " or the controller's namespace (if found)."
            )
        ),
    ] = None


class ManifestFrom(APIBaseModel):
    artifact: Annotated[Artifact, Field(description="Artifact contains the artifact to use")]


class DataSource(APIBaseModel):
    artifact_paths: Annotated[
        ArtifactPaths | None,
        Field(
            alias="artifactPaths",
            description=("ArtifactPaths is a data transformation that collects a list of artifact paths"),
        ),
    ] = None


class ResourceTemplate(APIBaseModel):
    action: Annotated[
        str,
        Field(
            description=(
                "Action is the action to perform to the resource. Must be one of: get,"
                " create, apply, delete, replace, patch"
            )
        ),
    ]
    failure_condition: Annotated[
        str | None,
        Field(
            alias="failureCondition",
            description=(
                "FailureCondition is a label selector expression which describes the"
                " conditions of the k8s resource in which the step was considered"
                " failed"
            ),
        ),
    ] = None
    flags: Annotated[
        list[str] | None,
        Field(
            description=(
                "Flags is a set of additional options passed to kubectl before"
                " submitting a resource I.e. to disable resource validation: flags:"
                ' [\n\t"--validate=false"  # disable resource validation\n]'
            )
        ),
    ] = None
    manifest: Annotated[str | None, Field(description="Manifest contains the kubernetes manifest")] = None
    manifest_from: Annotated[
        ManifestFrom | None,
        Field(
            alias="manifestFrom",
            description="ManifestFrom is the source for a single kubernetes manifest",
        ),
    ] = None
    merge_strategy: Annotated[
        str | None,
        Field(
            alias="mergeStrategy",
            description=(
                "MergeStrategy is the strategy used to merge a patch. It defaults to"
                ' "strategic" Must be one of: strategic, merge, json'
            ),
        ),
    ] = None
    set_owner_reference: Annotated[
        bool | None,
        Field(
            alias="setOwnerReference",
            description=(
                "SetOwnerReference sets the reference to the workflow on the OwnerReference of generated resource."
            ),
        ),
    ] = None
    success_condition: Annotated[
        str | None,
        Field(
            alias="successCondition",
            description=(
                "SuccessCondition is a label selector expression which describes the"
                " conditions of the k8s resource in which it is acceptable to proceed"
                " to the following step"
            ),
        ),
    ] = None


class Data(APIBaseModel):
    source: Annotated[
        DataSource,
        Field(description="Source sources external data into a data template"),
    ]
    transformation: Annotated[
        list[TransformationStep],
        Field(description="Transformation applies a set of transformations"),
    ]


class Arguments(APIBaseModel):
    artifacts: Annotated[
        list[Artifact] | None,
        Field(description=("Artifacts is the list of artifacts to pass to the template or workflow")),
    ] = None
    parameters: Annotated[
        list[Parameter] | None,
        Field(description=("Parameters is the list of parameters to pass to the template or workflow")),
    ] = None


class InfoResponse(APIBaseModel):
    columns: list[Column] | None = None
    links: list[Link] | None = None
    managed_namespace: Annotated[str | None, Field(alias="managedNamespace")] = None
    modals: Annotated[dict[str, bool] | None, Field(title="which modals to show")] = None
    nav_color: Annotated[str | None, Field(alias="navColor")] = None


class Inputs(APIBaseModel):
    artifacts: Annotated[
        list[Artifact] | None,
        Field(description="Artifact are a list of artifacts passed as inputs"),
    ] = None
    parameters: Annotated[
        list[Parameter] | None,
        Field(description="Parameters are a list of parameters passed as inputs"),
    ] = None


class Metrics(APIBaseModel):
    prometheus: Annotated[
        list[Prometheus] | None,
        Field(description="Prometheus is a list of prometheus metrics to be emitted"),
    ] = None


class Outputs(APIBaseModel):
    artifacts: Annotated[
        list[Artifact] | None,
        Field(description=("Artifacts holds the list of output artifacts produced by a step")),
    ] = None
    exit_code: Annotated[
        str | None,
        Field(
            alias="exitCode",
            description="ExitCode holds the exit code of a script template",
        ),
    ] = None
    parameters: Annotated[
        list[Parameter] | None,
        Field(description=("Parameters holds the list of output parameters produced by a step")),
    ] = None
    result: Annotated[
        str | None,
        Field(
            description=(
                "Result holds the result (stdout) of a script or container template, or"
                " the response body of an HTTP template"
            )
        ),
    ] = None


class LifecycleHook(APIBaseModel):
    arguments: Annotated[Arguments | None, Field(description="Arguments hold arguments to the template")] = None
    expression: Annotated[
        str | None,
        Field(
            description=(
                "Expression is a condition expression for when a node will be retried."
                " If it evaluates to false, the node will not be retried and the retry"
                " strategy will be ignored"
            )
        ),
    ] = None
    template: Annotated[
        str | None,
        Field(description="Template is the name of the template to execute by the hook"),
    ] = None
    template_ref: Annotated[
        TemplateRef | None,
        Field(
            alias="templateRef",
            description=("TemplateRef is the reference to the template resource to execute by the hook"),
        ),
    ] = None


class HTTP(APIBaseModel):
    body: Annotated[str | None, Field(description="Body is content of the HTTP Request")] = None
    body_from: Annotated[
        HTTPBodySource | None,
        Field(
            alias="bodyFrom",
            description="BodyFrom is  content of the HTTP Request as Bytes",
        ),
    ] = None
    headers: Annotated[
        list[HTTPHeader] | None,
        Field(description=("Headers are an optional list of headers to send with HTTP requests")),
    ] = None
    insecure_skip_verify: Annotated[
        bool | None,
        Field(
            alias="insecureSkipVerify",
            description=(
                "InsecureSkipVerify is a bool when if set to true will skip TLS verification for the HTTP client"
            ),
        ),
    ] = None
    method: Annotated[str | None, Field(description="Method is HTTP methods for HTTP Request")] = None
    success_condition: Annotated[
        str | None,
        Field(
            alias="successCondition",
            description=("SuccessCondition is an expression if evaluated to true is considered successful"),
        ),
    ] = None
    timeout_seconds: Annotated[
        int | None,
        Field(
            alias="timeoutSeconds",
            description=("TimeoutSeconds is request timeout for HTTP Request. Default is 30 seconds"),
        ),
    ] = None
    url: Annotated[str, Field(description="URL of the HTTP Request")]


class NodeStatus(APIBaseModel):
    boundary_id: Annotated[
        str | None,
        Field(
            alias="boundaryID",
            description=(
                "BoundaryID indicates the node ID of the associated template root node in which this node belongs to"
            ),
        ),
    ] = None
    children: Annotated[list[str] | None, Field(description="Children is a list of child node IDs")] = None
    daemoned: Annotated[
        bool | None,
        Field(description=("Daemoned tracks whether or not this node was daemoned and need to be terminated")),
    ] = None
    display_name: Annotated[
        str | None,
        Field(
            alias="displayName",
            description=(
                "DisplayName is a human readable representation of the node. Unique within a template boundary"
            ),
        ),
    ] = None
    estimated_duration: Annotated[
        int | None,
        Field(alias="estimatedDuration", description="EstimatedDuration in seconds."),
    ] = None
    finished_at: Annotated[
        v1_1.Time | None,
        Field(alias="finishedAt", description="Time at which this node completed"),
    ] = None
    host_node_name: Annotated[
        str | None,
        Field(
            alias="hostNodeName",
            description=("HostNodeName name of the Kubernetes node on which the Pod is running, if applicable"),
        ),
    ] = None
    id: Annotated[
        str,
        Field(
            description=(
                "ID is a unique identifier of a node within the worklow It is"
                " implemented as a hash of the node name, which makes the ID"
                " deterministic"
            )
        ),
    ]
    inputs: Annotated[
        Inputs | None,
        Field(
            description=(
                "Inputs captures input parameter values and artifact locations supplied to this template invocation"
            )
        ),
    ] = None
    memoization_status: Annotated[
        MemoizationStatus | None,
        Field(
            alias="memoizationStatus",
            description="MemoizationStatus holds information about cached nodes",
        ),
    ] = None
    message: Annotated[
        str | None,
        Field(description=("A human readable message indicating details about why the node is in this condition.")),
    ] = None
    name: Annotated[
        str,
        Field(description=("Name is unique name in the node tree used to generate the node ID")),
    ]
    node_flag: Annotated[
        NodeFlag | None,
        Field(
            alias="nodeFlag",
            description=("NodeFlag tracks some history of node. e.g.) hooked, retried, etc."),
        ),
    ] = None
    outbound_nodes: Annotated[
        list[str] | None,
        Field(
            alias="outboundNodes",
            description=(
                'OutboundNodes tracks the node IDs which are considered "outbound"'
                " nodes to a template invocation. For every invocation of a template,"
                ' there are nodes which we considered as "outbound". Essentially, these'
                " are last nodes in the execution sequence to run, before the template"
                " is considered completed. These nodes are then connected as parents to"
                " a following step.\n\nIn the case of single pod steps (i.e. container,"
                " script, resource templates), this list will be nil since the pod"
                ' itself is already considered the "outbound" node. In the case of'
                ' DAGs, outbound nodes are the "target" tasks (tasks with no children).'
                " In the case of steps, outbound nodes are all the containers involved"
                " in the last step group. NOTE: since templates are composable, the"
                " list of outbound nodes are carried upwards when a DAG/steps template"
                " invokes another DAG/steps template. In other words, the outbound"
                " nodes of a template, will be a superset of the outbound nodes of its"
                " last children."
            ),
        ),
    ] = None
    outputs: Annotated[
        Outputs | None,
        Field(
            description=(
                "Outputs captures output parameter values and artifact locations produced by this template invocation"
            )
        ),
    ] = None
    phase: Annotated[
        str | None,
        Field(
            description=(
                "Phase a simple, high-level summary of where the node is in its"
                " lifecycle. Can be used as a state machine. Will be one of these"
                ' values "Pending", "Running" before the node is completed, or'
                ' "Succeeded", "Skipped", "Failed", "Error", or "Omitted" as a final'
                " state."
            )
        ),
    ] = None
    pod_ip: Annotated[
        str | None,
        Field(
            alias="podIP",
            description="PodIP captures the IP of the pod for daemoned steps",
        ),
    ] = None
    progress: Annotated[str | None, Field(description="Progress to completion")] = None
    resources_duration: Annotated[
        dict[str, int] | None,
        Field(
            alias="resourcesDuration",
            description=(
                "ResourcesDuration is indicative, but not accurate, resource duration."
                " This is populated when the nodes completes."
            ),
        ),
    ] = None
    started_at: Annotated[
        v1_1.Time | None,
        Field(alias="startedAt", description="Time at which this node started"),
    ] = None
    synchronization_status: Annotated[
        NodeSynchronizationStatus | None,
        Field(
            alias="synchronizationStatus",
            description=("SynchronizationStatus is the synchronization status of the node"),
        ),
    ] = None
    task_result_synced: Annotated[
        bool | None,
        Field(
            alias="taskResultSynced",
            description=("TaskResultSynced is used to determine if the node's output has been received"),
        ),
    ] = None
    template_name: Annotated[
        str | None,
        Field(
            alias="templateName",
            description=(
                "TemplateName is the template name which this node corresponds to. Not"
                " applicable to virtual nodes (e.g. Retry, StepGroup)"
            ),
        ),
    ] = None
    template_ref: Annotated[
        TemplateRef | None,
        Field(
            alias="templateRef",
            description=(
                "TemplateRef is the reference to the template resource which this node"
                " corresponds to. Not applicable to virtual nodes (e.g. Retry,"
                " StepGroup)"
            ),
        ),
    ] = None
    template_scope: Annotated[
        str | None,
        Field(
            alias="templateScope",
            description=("TemplateScope is the template scope in which the template of this node was retrieved."),
        ),
    ] = None
    type: Annotated[str, Field(description="Type indicates type of node")]


class PodGC(APIBaseModel):
    delete_delay_duration: Annotated[
        str | None,
        Field(
            alias="deleteDelayDuration",
            description=("DeleteDelayDuration specifies the duration before pods in the GC queue get deleted."),
        ),
    ] = None
    label_selector: Annotated[
        v1_1.LabelSelector | None,
        Field(
            alias="labelSelector",
            description=(
                "LabelSelector is the label selector to check if the pods match the"
                " labels before being added to the pod GC queue."
            ),
        ),
    ] = None
    strategy: Annotated[
        str | None,
        Field(
            description=(
                'Strategy is the strategy to use. One of "OnPodCompletion",'
                ' "OnPodSuccess", "OnWorkflowCompletion", "OnWorkflowSuccess". If'
                " unset, does not delete Pods"
            )
        ),
    ] = None


class Submit(APIBaseModel):
    arguments: Annotated[
        Arguments | None,
        Field(description=("Arguments extracted from the event and then set as arguments to the workflow created.")),
    ] = None
    metadata: Annotated[
        v1_1.ObjectMeta | None,
        Field(description=("Metadata optional means to customize select fields of the workflow metadata")),
    ] = None
    workflow_template_ref: Annotated[
        WorkflowTemplateRef,
        Field(
            alias="workflowTemplateRef",
            description="WorkflowTemplateRef the workflow template to submit",
        ),
    ]


class WorkflowEventBindingSpec(APIBaseModel):
    event: Annotated[Event, Field(description="Event is the event to bind to")]
    submit: Annotated[Submit | None, Field(description="Submit is the workflow template to submit")] = None


class WorkflowEventBinding(APIBaseModel):
    api_version: Annotated[
        str | None,
        Field(
            alias="apiVersion",
            description=(
                "APIVersion defines the versioned schema of this representation of an"
                " object. Servers should convert recognized schemas to the latest"
                " internal value, and may reject unrecognized values. More info:"
                " https://git.io.k8s.community/contributors/devel/sig-architecture/api-conventions.md#resources"
            ),
        ),
    ] = None
    kind: Annotated[
        str | None,
        Field(
            description=(
                "Kind is a string value representing the REST resource this object"
                " represents. Servers may infer this from the endpoint the client"
                " submits requests to. Cannot be updated. In CamelCase. More info:"
                " https://git.io.k8s.community/contributors/devel/sig-architecture/api-conventions.md#types-kinds"
            )
        ),
    ] = None
    metadata: v1_1.ObjectMeta
    spec: WorkflowEventBindingSpec


class ContainerNode(APIBaseModel):
    args: Annotated[
        list[str] | None,
        Field(
            description=(
                "Arguments to the entrypoint. The container image's CMD is used if"
                " this is not provided. Variable references $(VAR_NAME) are expanded"
                " using the container's environment. If a variable cannot be resolved,"
                " the reference in the input string will be unchanged. Double $$ are"
                " reduced to a single $, which allows for escaping the $(VAR_NAME)"
                ' syntax: i.e. "$$(VAR_NAME)" will produce the string literal'
                ' "$(VAR_NAME)". Escaped references will never be expanded, regardless'
                " of whether the variable exists or not. Cannot be updated. More info:"
                " https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell"
            )
        ),
    ] = None
    command: Annotated[
        list[str] | None,
        Field(
            description=(
                "Entrypoint array. Not executed within a shell. The container image's"
                " ENTRYPOINT is used if this is not provided. Variable references"
                " $(VAR_NAME) are expanded using the container's environment. If a"
                " variable cannot be resolved, the reference in the input string will"
                " be unchanged. Double $$ are reduced to a single $, which allows for"
                ' escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will produce the'
                ' string literal "$(VAR_NAME)". Escaped references will never be'
                " expanded, regardless of whether the variable exists or not. Cannot be"
                " updated. More info:"
                " https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell"
            )
        ),
    ] = None
    dependencies: list[str] | None = None
    env: Annotated[
        list[v1.EnvVar] | None,
        Field(description=("List of environment variables to set in the container. Cannot be updated.")),
    ] = None
    env_from: Annotated[
        list[v1.EnvFromSource] | None,
        Field(
            alias="envFrom",
            description=(
                "List of sources to populate environment variables in the container."
                " The keys defined within a source must be a C_IDENTIFIER. All invalid"
                " keys will be reported as an event when the container is starting."
                " When a key exists in multiple sources, the value associated with the"
                " last source will take precedence. Values defined by an Env with a"
                " duplicate key will take precedence. Cannot be updated."
            ),
        ),
    ] = None
    image: Annotated[
        str | None,
        Field(
            description=(
                "Container image name. More info:"
                " https://kubernetes.io/docs/concepts/containers/images This field is"
                " optional to allow higher level config management to default or"
                " override container images in workload controllers like Deployments"
                " and StatefulSets."
            )
        ),
    ] = None
    image_pull_policy: Annotated[
        str | None,
        Field(
            alias="imagePullPolicy",
            description=(
                "Image pull policy. One of Always, Never, IfNotPresent. Defaults to"
                " Always if :latest tag is specified, or IfNotPresent otherwise. Cannot"
                " be updated. More info:"
                " https://kubernetes.io/docs/concepts/containers/images#updating-images"
            ),
        ),
    ] = None
    lifecycle: Annotated[
        v1.Lifecycle | None,
        Field(
            description=(
                "Actions that the management system should take in response to"
                " container lifecycle events. Cannot be updated."
            )
        ),
    ] = None
    liveness_probe: Annotated[
        v1.Probe | None,
        Field(
            alias="livenessProbe",
            description=(
                "Periodic probe of container liveness. Container will be restarted if"
                " the probe fails. Cannot be updated. More info:"
                " https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes"
            ),
        ),
    ] = None
    name: Annotated[
        str,
        Field(
            description=(
                "Name of the container specified as a DNS_LABEL. Each container in a"
                " pod must have a unique name (DNS_LABEL). Cannot be updated."
            )
        ),
    ]
    ports: Annotated[
        list[v1.ContainerPort] | None,
        Field(
            description=(
                "List of ports to expose from the container. Not specifying a port here"
                " DOES NOT prevent that port from being exposed. Any port which is"
                ' listening on the default "0.0.0.0" address inside a container will be'
                " accessible from the network. Modifying this array with strategic"
                " merge patch may corrupt the data. For more information See"
                " https://github.com/kubernetes/kubernetes/issues/108255. Cannot be"
                " updated."
            )
        ),
    ] = None
    readiness_probe: Annotated[
        v1.Probe | None,
        Field(
            alias="readinessProbe",
            description=(
                "Periodic probe of container service readiness. Container will be"
                " removed from service endpoints if the probe fails. Cannot be updated."
                " More info:"
                " https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes"
            ),
        ),
    ] = None
    resize_policy: Annotated[
        list[v1.ContainerResizePolicy] | None,
        Field(
            alias="resizePolicy",
            description="Resources resize policy for the container.",
        ),
    ] = None
    resources: Annotated[
        v1.ResourceRequirements | None,
        Field(
            description=(
                "Compute Resources required by this container. Cannot be updated. More"
                " info:"
                " https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/"
            )
        ),
    ] = None
    restart_policy: Annotated[
        str | None,
        Field(
            alias="restartPolicy",
            description=(
                "RestartPolicy defines the restart behavior of individual containers in"
                " a pod. This field may only be set for init containers, and the only"
                ' allowed value is "Always". For non-init containers or when this field'
                " is not specified, the restart behavior is defined by the Pod's"
                " restart policy and the container type. Setting the RestartPolicy as"
                ' "Always" for the init container will have the following effect: this'
                " init container will be continually restarted on exit until all"
                " regular containers have terminated. Once all regular containers have"
                ' completed, all init containers with restartPolicy "Always" will be'
                " shut down. This lifecycle differs from normal init containers and is"
                ' often referred to as a "sidecar" container. Although this init'
                " container still starts in the init container sequence, it does not"
                " wait for the container to complete before proceeding to the next init"
                " container. Instead, the next init container starts immediately after"
                " this init container is started, or after any startupProbe has"
                " successfully completed."
            ),
        ),
    ] = None
    security_context: Annotated[
        v1.SecurityContext | None,
        Field(
            alias="securityContext",
            description=(
                "SecurityContext defines the security options the container should be"
                " run with. If set, the fields of SecurityContext override the"
                " equivalent fields of PodSecurityContext. More info:"
                " https://kubernetes.io/docs/tasks/configure-pod-container/security-context/"
            ),
        ),
    ] = None
    startup_probe: Annotated[
        v1.Probe | None,
        Field(
            alias="startupProbe",
            description=(
                "StartupProbe indicates that the Pod has successfully initialized. If"
                " specified, no other probes are executed until this completes"
                " successfully. If this probe fails, the Pod will be restarted, just as"
                " if the livenessProbe failed. This can be used to provide different"
                " probe parameters at the beginning of a Pod's lifecycle, when it might"
                " take a long time to load data or warm a cache, than during"
                " steady-state operation. This cannot be updated. More info:"
                " https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes"
            ),
        ),
    ] = None
    stdin: Annotated[
        bool | None,
        Field(
            description=(
                "Whether this container should allocate a buffer for stdin in the"
                " container runtime. If this is not set, reads from stdin in the"
                " container will always result in EOF. Default is false."
            )
        ),
    ] = None
    stdin_once: Annotated[
        bool | None,
        Field(
            alias="stdinOnce",
            description=(
                "Whether the container runtime should close the stdin channel after it"
                " has been opened by a single attach. When stdin is true the stdin"
                " stream will remain open across multiple attach sessions. If stdinOnce"
                " is set to true, stdin is opened on container start, is empty until"
                " the first client attaches to stdin, and then remains open and accepts"
                " data until the client disconnects, at which time stdin is closed and"
                " remains closed until the container is restarted. If this flag is"
                " false, a container processes that reads from stdin will never receive"
                " an EOF. Default is false"
            ),
        ),
    ] = None
    termination_message_path: Annotated[
        str | None,
        Field(
            alias="terminationMessagePath",
            description=(
                "Optional: Path at which the file to which the container's termination"
                " message will be written is mounted into the container's filesystem."
                " Message written is intended to be brief final status, such as an"
                " assertion failure message. Will be truncated by the node if greater"
                " than 4096 bytes. The total message length across all containers will"
                " be limited to 12kb. Defaults to /dev/termination-log. Cannot be"
                " updated."
            ),
        ),
    ] = None
    termination_message_policy: Annotated[
        str | None,
        Field(
            alias="terminationMessagePolicy",
            description=(
                "Indicate how the termination message should be populated. File will"
                " use the contents of terminationMessagePath to populate the container"
                " status message on both success and failure. FallbackToLogsOnError"
                " will use the last chunk of container log output if the termination"
                " message file is empty and the container exited with an error. The log"
                " output is limited to 2048 bytes or 80 lines, whichever is smaller."
                " Defaults to File. Cannot be updated."
            ),
        ),
    ] = None
    tty: Annotated[
        bool | None,
        Field(
            description=(
                "Whether this container should allocate a TTY for itself, also requires"
                " 'stdin' to be true. Default is false."
            )
        ),
    ] = None
    volume_devices: Annotated[
        list[v1.VolumeDevice] | None,
        Field(
            alias="volumeDevices",
            description=("volumeDevices is the list of block devices to be used by the container."),
        ),
    ] = None
    volume_mounts: Annotated[
        list[v1.VolumeMount] | None,
        Field(
            alias="volumeMounts",
            description=("Pod volumes to mount into the container's filesystem. Cannot be updated."),
        ),
    ] = None
    working_dir: Annotated[
        str | None,
        Field(
            alias="workingDir",
            description=(
                "Container's working directory. If not specified, the container"
                " runtime's default will be used, which might be configured in the"
                " container image. Cannot be updated."
            ),
        ),
    ] = None


class ScriptTemplate(APIBaseModel):
    args: Annotated[
        list[str] | None,
        Field(
            description=(
                "Arguments to the entrypoint. The container image's CMD is used if"
                " this is not provided. Variable references $(VAR_NAME) are expanded"
                " using the container's environment. If a variable cannot be resolved,"
                " the reference in the input string will be unchanged. Double $$ are"
                " reduced to a single $, which allows for escaping the $(VAR_NAME)"
                ' syntax: i.e. "$$(VAR_NAME)" will produce the string literal'
                ' "$(VAR_NAME)". Escaped references will never be expanded, regardless'
                " of whether the variable exists or not. Cannot be updated. More info:"
                " https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell"
            )
        ),
    ] = None
    command: Annotated[
        list[str] | None,
        Field(
            description=(
                "Entrypoint array. Not executed within a shell. The container image's"
                " ENTRYPOINT is used if this is not provided. Variable references"
                " $(VAR_NAME) are expanded using the container's environment. If a"
                " variable cannot be resolved, the reference in the input string will"
                " be unchanged. Double $$ are reduced to a single $, which allows for"
                ' escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will produce the'
                ' string literal "$(VAR_NAME)". Escaped references will never be'
                " expanded, regardless of whether the variable exists or not. Cannot be"
                " updated. More info:"
                " https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell"
            )
        ),
    ] = None
    env: Annotated[
        list[v1.EnvVar] | None,
        Field(description=("List of environment variables to set in the container. Cannot be updated.")),
    ] = None
    env_from: Annotated[
        list[v1.EnvFromSource] | None,
        Field(
            alias="envFrom",
            description=(
                "List of sources to populate environment variables in the container."
                " The keys defined within a source must be a C_IDENTIFIER. All invalid"
                " keys will be reported as an event when the container is starting."
                " When a key exists in multiple sources, the value associated with the"
                " last source will take precedence. Values defined by an Env with a"
                " duplicate key will take precedence. Cannot be updated."
            ),
        ),
    ] = None
    image: Annotated[
        str,
        Field(
            description=(
                "Container image name. More info:"
                " https://kubernetes.io/docs/concepts/containers/images This field is"
                " optional to allow higher level config management to default or"
                " override container images in workload controllers like Deployments"
                " and StatefulSets."
            )
        ),
    ]
    image_pull_policy: Annotated[
        str | None,
        Field(
            alias="imagePullPolicy",
            description=(
                "Image pull policy. One of Always, Never, IfNotPresent. Defaults to"
                " Always if :latest tag is specified, or IfNotPresent otherwise. Cannot"
                " be updated. More info:"
                " https://kubernetes.io/docs/concepts/containers/images#updating-images"
            ),
        ),
    ] = None
    lifecycle: Annotated[
        v1.Lifecycle | None,
        Field(
            description=(
                "Actions that the management system should take in response to"
                " container lifecycle events. Cannot be updated."
            )
        ),
    ] = None
    liveness_probe: Annotated[
        v1.Probe | None,
        Field(
            alias="livenessProbe",
            description=(
                "Periodic probe of container liveness. Container will be restarted if"
                " the probe fails. Cannot be updated. More info:"
                " https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes"
            ),
        ),
    ] = None
    name: Annotated[
        str | None,
        Field(
            description=(
                "Name of the container specified as a DNS_LABEL. Each container in a"
                " pod must have a unique name (DNS_LABEL). Cannot be updated."
            )
        ),
    ] = None
    ports: Annotated[
        list[v1.ContainerPort] | None,
        Field(
            description=(
                "List of ports to expose from the container. Not specifying a port here"
                " DOES NOT prevent that port from being exposed. Any port which is"
                ' listening on the default "0.0.0.0" address inside a container will be'
                " accessible from the network. Modifying this array with strategic"
                " merge patch may corrupt the data. For more information See"
                " https://github.com/kubernetes/kubernetes/issues/108255. Cannot be"
                " updated."
            )
        ),
    ] = None
    readiness_probe: Annotated[
        v1.Probe | None,
        Field(
            alias="readinessProbe",
            description=(
                "Periodic probe of container service readiness. Container will be"
                " removed from service endpoints if the probe fails. Cannot be updated."
                " More info:"
                " https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes"
            ),
        ),
    ] = None
    resize_policy: Annotated[
        list[v1.ContainerResizePolicy] | None,
        Field(
            alias="resizePolicy",
            description="Resources resize policy for the container.",
        ),
    ] = None
    resources: Annotated[
        v1.ResourceRequirements | None,
        Field(
            description=(
                "Compute Resources required by this container. Cannot be updated. More"
                " info:"
                " https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/"
            )
        ),
    ] = None
    restart_policy: Annotated[
        str | None,
        Field(
            alias="restartPolicy",
            description=(
                "RestartPolicy defines the restart behavior of individual containers in"
                " a pod. This field may only be set for init containers, and the only"
                ' allowed value is "Always". For non-init containers or when this field'
                " is not specified, the restart behavior is defined by the Pod's"
                " restart policy and the container type. Setting the RestartPolicy as"
                ' "Always" for the init container will have the following effect: this'
                " init container will be continually restarted on exit until all"
                " regular containers have terminated. Once all regular containers have"
                ' completed, all init containers with restartPolicy "Always" will be'
                " shut down. This lifecycle differs from normal init containers and is"
                ' often referred to as a "sidecar" container. Although this init'
                " container still starts in the init container sequence, it does not"
                " wait for the container to complete before proceeding to the next init"
                " container. Instead, the next init container starts immediately after"
                " this init container is started, or after any startupProbe has"
                " successfully completed."
            ),
        ),
    ] = None
    security_context: Annotated[
        v1.SecurityContext | None,
        Field(
            alias="securityContext",
            description=(
                "SecurityContext defines the security options the container should be"
                " run with. If set, the fields of SecurityContext override the"
                " equivalent fields of PodSecurityContext. More info:"
                " https://kubernetes.io/docs/tasks/configure-pod-container/security-context/"
            ),
        ),
    ] = None
    source: Annotated[
        str,
        Field(description="Source contains the source code of the script to execute"),
    ]
    startup_probe: Annotated[
        v1.Probe | None,
        Field(
            alias="startupProbe",
            description=(
                "StartupProbe indicates that the Pod has successfully initialized. If"
                " specified, no other probes are executed until this completes"
                " successfully. If this probe fails, the Pod will be restarted, just as"
                " if the livenessProbe failed. This can be used to provide different"
                " probe parameters at the beginning of a Pod's lifecycle, when it might"
                " take a long time to load data or warm a cache, than during"
                " steady-state operation. This cannot be updated. More info:"
                " https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes"
            ),
        ),
    ] = None
    stdin: Annotated[
        bool | None,
        Field(
            description=(
                "Whether this container should allocate a buffer for stdin in the"
                " container runtime. If this is not set, reads from stdin in the"
                " container will always result in EOF. Default is false."
            )
        ),
    ] = None
    stdin_once: Annotated[
        bool | None,
        Field(
            alias="stdinOnce",
            description=(
                "Whether the container runtime should close the stdin channel after it"
                " has been opened by a single attach. When stdin is true the stdin"
                " stream will remain open across multiple attach sessions. If stdinOnce"
                " is set to true, stdin is opened on container start, is empty until"
                " the first client attaches to stdin, and then remains open and accepts"
                " data until the client disconnects, at which time stdin is closed and"
                " remains closed until the container is restarted. If this flag is"
                " false, a container processes that reads from stdin will never receive"
                " an EOF. Default is false"
            ),
        ),
    ] = None
    termination_message_path: Annotated[
        str | None,
        Field(
            alias="terminationMessagePath",
            description=(
                "Optional: Path at which the file to which the container's termination"
                " message will be written is mounted into the container's filesystem."
                " Message written is intended to be brief final status, such as an"
                " assertion failure message. Will be truncated by the node if greater"
                " than 4096 bytes. The total message length across all containers will"
                " be limited to 12kb. Defaults to /dev/termination-log. Cannot be"
                " updated."
            ),
        ),
    ] = None
    termination_message_policy: Annotated[
        str | None,
        Field(
            alias="terminationMessagePolicy",
            description=(
                "Indicate how the termination message should be populated. File will"
                " use the contents of terminationMessagePath to populate the container"
                " status message on both success and failure. FallbackToLogsOnError"
                " will use the last chunk of container log output if the termination"
                " message file is empty and the container exited with an error. The log"
                " output is limited to 2048 bytes or 80 lines, whichever is smaller."
                " Defaults to File. Cannot be updated."
            ),
        ),
    ] = None
    tty: Annotated[
        bool | None,
        Field(
            description=(
                "Whether this container should allocate a TTY for itself, also requires"
                " 'stdin' to be true. Default is false."
            )
        ),
    ] = None
    volume_devices: Annotated[
        list[v1.VolumeDevice] | None,
        Field(
            alias="volumeDevices",
            description=("volumeDevices is the list of block devices to be used by the container."),
        ),
    ] = None
    volume_mounts: Annotated[
        list[v1.VolumeMount] | None,
        Field(
            alias="volumeMounts",
            description=("Pod volumes to mount into the container's filesystem. Cannot be updated."),
        ),
    ] = None
    working_dir: Annotated[
        str | None,
        Field(
            alias="workingDir",
            description=(
                "Container's working directory. If not specified, the container"
                " runtime's default will be used, which might be configured in the"
                " container image. Cannot be updated."
            ),
        ),
    ] = None


class UserContainer(APIBaseModel):
    args: Annotated[
        list[str] | None,
        Field(
            description=(
                "Arguments to the entrypoint. The container image's CMD is used if"
                " this is not provided. Variable references $(VAR_NAME) are expanded"
                " using the container's environment. If a variable cannot be resolved,"
                " the reference in the input string will be unchanged. Double $$ are"
                " reduced to a single $, which allows for escaping the $(VAR_NAME)"
                ' syntax: i.e. "$$(VAR_NAME)" will produce the string literal'
                ' "$(VAR_NAME)". Escaped references will never be expanded, regardless'
                " of whether the variable exists or not. Cannot be updated. More info:"
                " https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell"
            )
        ),
    ] = None
    command: Annotated[
        list[str] | None,
        Field(
            description=(
                "Entrypoint array. Not executed within a shell. The container image's"
                " ENTRYPOINT is used if this is not provided. Variable references"
                " $(VAR_NAME) are expanded using the container's environment. If a"
                " variable cannot be resolved, the reference in the input string will"
                " be unchanged. Double $$ are reduced to a single $, which allows for"
                ' escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will produce the'
                ' string literal "$(VAR_NAME)". Escaped references will never be'
                " expanded, regardless of whether the variable exists or not. Cannot be"
                " updated. More info:"
                " https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell"
            )
        ),
    ] = None
    env: Annotated[
        list[v1.EnvVar] | None,
        Field(description=("List of environment variables to set in the container. Cannot be updated.")),
    ] = None
    env_from: Annotated[
        list[v1.EnvFromSource] | None,
        Field(
            alias="envFrom",
            description=(
                "List of sources to populate environment variables in the container."
                " The keys defined within a source must be a C_IDENTIFIER. All invalid"
                " keys will be reported as an event when the container is starting."
                " When a key exists in multiple sources, the value associated with the"
                " last source will take precedence. Values defined by an Env with a"
                " duplicate key will take precedence. Cannot be updated."
            ),
        ),
    ] = None
    image: Annotated[
        str | None,
        Field(
            description=(
                "Container image name. More info:"
                " https://kubernetes.io/docs/concepts/containers/images This field is"
                " optional to allow higher level config management to default or"
                " override container images in workload controllers like Deployments"
                " and StatefulSets."
            )
        ),
    ] = None
    image_pull_policy: Annotated[
        str | None,
        Field(
            alias="imagePullPolicy",
            description=(
                "Image pull policy. One of Always, Never, IfNotPresent. Defaults to"
                " Always if :latest tag is specified, or IfNotPresent otherwise. Cannot"
                " be updated. More info:"
                " https://kubernetes.io/docs/concepts/containers/images#updating-images"
            ),
        ),
    ] = None
    lifecycle: Annotated[
        v1.Lifecycle | None,
        Field(
            description=(
                "Actions that the management system should take in response to"
                " container lifecycle events. Cannot be updated."
            )
        ),
    ] = None
    liveness_probe: Annotated[
        v1.Probe | None,
        Field(
            alias="livenessProbe",
            description=(
                "Periodic probe of container liveness. Container will be restarted if"
                " the probe fails. Cannot be updated. More info:"
                " https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes"
            ),
        ),
    ] = None
    mirror_volume_mounts: Annotated[
        bool | None,
        Field(
            alias="mirrorVolumeMounts",
            description=(
                "MirrorVolumeMounts will mount the same volumes specified in the main"
                " container to the container (including artifacts), at the same"
                " mountPaths. This enables dind daemon to partially see the same"
                " filesystem as the main container in order to use features such as"
                " docker volume binding"
            ),
        ),
    ] = None
    name: Annotated[
        str,
        Field(
            description=(
                "Name of the container specified as a DNS_LABEL. Each container in a"
                " pod must have a unique name (DNS_LABEL). Cannot be updated."
            )
        ),
    ]
    ports: Annotated[
        list[v1.ContainerPort] | None,
        Field(
            description=(
                "List of ports to expose from the container. Not specifying a port here"
                " DOES NOT prevent that port from being exposed. Any port which is"
                ' listening on the default "0.0.0.0" address inside a container will be'
                " accessible from the network. Modifying this array with strategic"
                " merge patch may corrupt the data. For more information See"
                " https://github.com/kubernetes/kubernetes/issues/108255. Cannot be"
                " updated."
            )
        ),
    ] = None
    readiness_probe: Annotated[
        v1.Probe | None,
        Field(
            alias="readinessProbe",
            description=(
                "Periodic probe of container service readiness. Container will be"
                " removed from service endpoints if the probe fails. Cannot be updated."
                " More info:"
                " https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes"
            ),
        ),
    ] = None
    resize_policy: Annotated[
        list[v1.ContainerResizePolicy] | None,
        Field(
            alias="resizePolicy",
            description="Resources resize policy for the container.",
        ),
    ] = None
    resources: Annotated[
        v1.ResourceRequirements | None,
        Field(
            description=(
                "Compute Resources required by this container. Cannot be updated. More"
                " info:"
                " https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/"
            )
        ),
    ] = None
    restart_policy: Annotated[
        str | None,
        Field(
            alias="restartPolicy",
            description=(
                "RestartPolicy defines the restart behavior of individual containers in"
                " a pod. This field may only be set for init containers, and the only"
                ' allowed value is "Always". For non-init containers or when this field'
                " is not specified, the restart behavior is defined by the Pod's"
                " restart policy and the container type. Setting the RestartPolicy as"
                ' "Always" for the init container will have the following effect: this'
                " init container will be continually restarted on exit until all"
                " regular containers have terminated. Once all regular containers have"
                ' completed, all init containers with restartPolicy "Always" will be'
                " shut down. This lifecycle differs from normal init containers and is"
                ' often referred to as a "sidecar" container. Although this init'
                " container still starts in the init container sequence, it does not"
                " wait for the container to complete before proceeding to the next init"
                " container. Instead, the next init container starts immediately after"
                " this init container is started, or after any startupProbe has"
                " successfully completed."
            ),
        ),
    ] = None
    security_context: Annotated[
        v1.SecurityContext | None,
        Field(
            alias="securityContext",
            description=(
                "SecurityContext defines the security options the container should be"
                " run with. If set, the fields of SecurityContext override the"
                " equivalent fields of PodSecurityContext. More info:"
                " https://kubernetes.io/docs/tasks/configure-pod-container/security-context/"
            ),
        ),
    ] = None
    startup_probe: Annotated[
        v1.Probe | None,
        Field(
            alias="startupProbe",
            description=(
                "StartupProbe indicates that the Pod has successfully initialized. If"
                " specified, no other probes are executed until this completes"
                " successfully. If this probe fails, the Pod will be restarted, just as"
                " if the livenessProbe failed. This can be used to provide different"
                " probe parameters at the beginning of a Pod's lifecycle, when it might"
                " take a long time to load data or warm a cache, than during"
                " steady-state operation. This cannot be updated. More info:"
                " https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes"
            ),
        ),
    ] = None
    stdin: Annotated[
        bool | None,
        Field(
            description=(
                "Whether this container should allocate a buffer for stdin in the"
                " container runtime. If this is not set, reads from stdin in the"
                " container will always result in EOF. Default is false."
            )
        ),
    ] = None
    stdin_once: Annotated[
        bool | None,
        Field(
            alias="stdinOnce",
            description=(
                "Whether the container runtime should close the stdin channel after it"
                " has been opened by a single attach. When stdin is true the stdin"
                " stream will remain open across multiple attach sessions. If stdinOnce"
                " is set to true, stdin is opened on container start, is empty until"
                " the first client attaches to stdin, and then remains open and accepts"
                " data until the client disconnects, at which time stdin is closed and"
                " remains closed until the container is restarted. If this flag is"
                " false, a container processes that reads from stdin will never receive"
                " an EOF. Default is false"
            ),
        ),
    ] = None
    termination_message_path: Annotated[
        str | None,
        Field(
            alias="terminationMessagePath",
            description=(
                "Optional: Path at which the file to which the container's termination"
                " message will be written is mounted into the container's filesystem."
                " Message written is intended to be brief final status, such as an"
                " assertion failure message. Will be truncated by the node if greater"
                " than 4096 bytes. The total message length across all containers will"
                " be limited to 12kb. Defaults to /dev/termination-log. Cannot be"
                " updated."
            ),
        ),
    ] = None
    termination_message_policy: Annotated[
        str | None,
        Field(
            alias="terminationMessagePolicy",
            description=(
                "Indicate how the termination message should be populated. File will"
                " use the contents of terminationMessagePath to populate the container"
                " status message on both success and failure. FallbackToLogsOnError"
                " will use the last chunk of container log output if the termination"
                " message file is empty and the container exited with an error. The log"
                " output is limited to 2048 bytes or 80 lines, whichever is smaller."
                " Defaults to File. Cannot be updated."
            ),
        ),
    ] = None
    tty: Annotated[
        bool | None,
        Field(
            description=(
                "Whether this container should allocate a TTY for itself, also requires"
                " 'stdin' to be true. Default is false."
            )
        ),
    ] = None
    volume_devices: Annotated[
        list[v1.VolumeDevice] | None,
        Field(
            alias="volumeDevices",
            description=("volumeDevices is the list of block devices to be used by the container."),
        ),
    ] = None
    volume_mounts: Annotated[
        list[v1.VolumeMount] | None,
        Field(
            alias="volumeMounts",
            description=("Pod volumes to mount into the container's filesystem. Cannot be updated."),
        ),
    ] = None
    working_dir: Annotated[
        str | None,
        Field(
            alias="workingDir",
            description=(
                "Container's working directory. If not specified, the container"
                " runtime's default will be used, which might be configured in the"
                " container image. Cannot be updated."
            ),
        ),
    ] = None


class WorkflowEventBindingList(APIBaseModel):
    api_version: Annotated[
        str | None,
        Field(
            alias="apiVersion",
            description=(
                "APIVersion defines the versioned schema of this representation of an"
                " object. Servers should convert recognized schemas to the latest"
                " internal value, and may reject unrecognized values. More info:"
                " https://git.io.k8s.community/contributors/devel/sig-architecture/api-conventions.md#resources"
            ),
        ),
    ] = None
    items: list[WorkflowEventBinding] | None = None
    kind: Annotated[
        str | None,
        Field(
            description=(
                "Kind is a string value representing the REST resource this object"
                " represents. Servers may infer this from the endpoint the client"
                " submits requests to. Cannot be updated. In CamelCase. More info:"
                " https://git.io.k8s.community/contributors/devel/sig-architecture/api-conventions.md#types-kinds"
            )
        ),
    ] = None
    metadata: v1_1.ListMeta


class ContainerSetTemplate(APIBaseModel):
    containers: list[ContainerNode]
    retry_strategy: Annotated[
        ContainerSetRetryStrategy | None,
        Field(
            alias="retryStrategy",
            description=(
                "RetryStrategy describes how to retry container nodes if the container"
                " set fails. Note that this works differently from the template-level"
                " `retryStrategy` as it is a process-level retry that does not create"
                " new Pods or containers."
            ),
        ),
    ] = None
    volume_mounts: Annotated[list[v1.VolumeMount] | None, Field(alias="volumeMounts")] = None


class DAGTemplate(APIBaseModel):
    fail_fast: Annotated[
        bool | None,
        Field(
            alias="failFast",
            description=(
                'This flag is for DAG logic. The DAG logic has a built-in "fail fast"'
                " feature to stop scheduling new steps, as soon as it detects that one"
                " of the DAG nodes is failed. Then it waits until all DAG nodes are"
                " completed before failing the DAG itself. The FailFast flag default is"
                " true,  if set to false, it will allow a DAG to run all branches of"
                " the DAG to completion (either success or failure), regardless of the"
                " failed outcomes of branches in the DAG. More info and example about"
                " this feature at"
                " https://github.com/argoproj/argo-workflows/issues/1442"
            ),
        ),
    ] = None
    target: Annotated[
        str | None,
        Field(description="Target are one or more names of targets to execute in a DAG"),
    ] = None
    tasks: Annotated[list[DAGTask], Field(description="Tasks are a list of DAG tasks")]


class ClusterWorkflowTemplateList(APIBaseModel):
    api_version: Annotated[
        str | None,
        Field(
            alias="apiVersion",
            description=(
                "APIVersion defines the versioned schema of this representation of an"
                " object. Servers should convert recognized schemas to the latest"
                " internal value, and may reject unrecognized values. More info:"
                " https://git.io.k8s.community/contributors/devel/sig-architecture/api-conventions.md#resources"
            ),
        ),
    ] = None
    items: list[ClusterWorkflowTemplate] | None = None
    kind: Annotated[
        str | None,
        Field(
            description=(
                "Kind is a string value representing the REST resource this object"
                " represents. Servers may infer this from the endpoint the client"
                " submits requests to. Cannot be updated. In CamelCase. More info:"
                " https://git.io.k8s.community/contributors/devel/sig-architecture/api-conventions.md#types-kinds"
            )
        ),
    ] = None
    metadata: v1_1.ListMeta


class CronWorkflowList(APIBaseModel):
    api_version: Annotated[
        str | None,
        Field(
            alias="apiVersion",
            description=(
                "APIVersion defines the versioned schema of this representation of an"
                " object. Servers should convert recognized schemas to the latest"
                " internal value, and may reject unrecognized values. More info:"
                " https://git.io.k8s.community/contributors/devel/sig-architecture/api-conventions.md#resources"
            ),
        ),
    ] = None
    items: list[CronWorkflow] | None = None
    kind: Annotated[
        str | None,
        Field(
            description=(
                "Kind is a string value representing the REST resource this object"
                " represents. Servers may infer this from the endpoint the client"
                " submits requests to. Cannot be updated. In CamelCase. More info:"
                " https://git.io.k8s.community/contributors/devel/sig-architecture/api-conventions.md#types-kinds"
            )
        ),
    ] = None
    metadata: v1_1.ListMeta


class WorkflowList(APIBaseModel):
    api_version: Annotated[
        str | None,
        Field(
            alias="apiVersion",
            description=(
                "APIVersion defines the versioned schema of this representation of an"
                " object. Servers should convert recognized schemas to the latest"
                " internal value, and may reject unrecognized values. More info:"
                " https://git.io.k8s.community/contributors/devel/sig-architecture/api-conventions.md#resources"
            ),
        ),
    ] = None
    items: list[Workflow] | None = None
    kind: Annotated[
        str | None,
        Field(
            description=(
                "Kind is a string value representing the REST resource this object"
                " represents. Servers may infer this from the endpoint the client"
                " submits requests to. Cannot be updated. In CamelCase. More info:"
                " https://git.io.k8s.community/contributors/devel/sig-architecture/api-conventions.md#types-kinds"
            )
        ),
    ] = None
    metadata: v1_1.ListMeta


class WorkflowTemplateList(APIBaseModel):
    api_version: Annotated[
        str | None,
        Field(
            alias="apiVersion",
            description=(
                "APIVersion defines the versioned schema of this representation of an"
                " object. Servers should convert recognized schemas to the latest"
                " internal value, and may reject unrecognized values. More info:"
                " https://git.io.k8s.community/contributors/devel/sig-architecture/api-conventions.md#resources"
            ),
        ),
    ] = None
    items: list[WorkflowTemplate] | None = None
    kind: Annotated[
        str | None,
        Field(
            description=(
                "Kind is a string value representing the REST resource this object"
                " represents. Servers may infer this from the endpoint the client"
                " submits requests to. Cannot be updated. In CamelCase. More info:"
                " https://git.io.k8s.community/contributors/devel/sig-architecture/api-conventions.md#types-kinds"
            )
        ),
    ] = None
    metadata: v1_1.ListMeta


class Template(APIBaseModel):
    active_deadline_seconds: Annotated[
        intstr.IntOrString | None,
        Field(
            alias="activeDeadlineSeconds",
            description=(
                "Optional duration in seconds relative to the StartTime that the pod"
                " may be active on a node before the system actively tries to terminate"
                " the pod; value must be positive integer This field is only applicable"
                " to container and script templates."
            ),
        ),
    ] = None
    affinity: Annotated[
        v1.Affinity | None,
        Field(
            description=(
                "Affinity sets the pod's scheduling constraints Overrides the affinity"
                " set at the workflow level (if any)"
            )
        ),
    ] = None
    annotations: Annotated[
        dict[str, str] | None,
        Field(description=("Annotations is a list of annotations to add to the template at runtime")),
    ] = None
    archive_location: Annotated[
        ArtifactLocation | None,
        Field(
            alias="archiveLocation",
            description=(
                "Location in which all files related to the step will be stored (logs,"
                " artifacts, etc...). Can be overridden by individual items in Outputs."
                " If omitted, will use the default artifact repository location"
                " configured in the controller, appended with the"
                " <workflowname>/<nodename> in the key."
            ),
        ),
    ] = None
    automount_service_account_token: Annotated[
        bool | None,
        Field(
            alias="automountServiceAccountToken",
            description=(
                "AutomountServiceAccountToken indicates whether a service account token"
                " should be automatically mounted in pods. ServiceAccountName of"
                " ExecutorConfig must be specified if this value is false."
            ),
        ),
    ] = None
    container: Annotated[
        v1.Container | None,
        Field(description="Container is the main container image to run in the pod"),
    ] = None
    container_set: Annotated[
        ContainerSetTemplate | None,
        Field(
            alias="containerSet",
            description="ContainerSet groups multiple containers within a single pod.",
        ),
    ] = None
    daemon: Annotated[
        bool | None,
        Field(
            description=(
                "Daemon will allow a workflow to proceed to the next step so long as the container reaches readiness"
            )
        ),
    ] = None
    dag: Annotated[DAGTemplate | None, Field(description="DAG template subtype which runs a DAG")] = None
    data: Annotated[Data | None, Field(description="Data is a data template")] = None
    executor: Annotated[
        ExecutorConfig | None,
        Field(description="Executor holds configurations of the executor container."),
    ] = None
    fail_fast: Annotated[
        bool | None,
        Field(
            alias="failFast",
            description=(
                "FailFast, if specified, will fail this template if any of its child"
                " pods has failed. This is useful for when this template is expanded"
                " with `withItems`, etc."
            ),
        ),
    ] = None
    host_aliases: Annotated[
        list[v1.HostAlias] | None,
        Field(
            alias="hostAliases",
            description=("HostAliases is an optional list of hosts and IPs that will be injected into the pod spec"),
        ),
    ] = None
    http: Annotated[HTTP | None, Field(description="HTTP makes a HTTP request")] = None
    init_containers: Annotated[
        list[UserContainer] | None,
        Field(
            alias="initContainers",
            description=("InitContainers is a list of containers which run before the main container."),
        ),
    ] = None
    inputs: Annotated[
        Inputs | None,
        Field(description=("Inputs describe what inputs parameters and artifacts are supplied to this template")),
    ] = None
    memoize: Annotated[
        Memoize | None,
        Field(description=("Memoize allows templates to use outputs generated from already executed templates")),
    ] = None
    metadata: Annotated[
        Metadata | None,
        Field(description="Metdata sets the pods's metadata, i.e. annotations and labels"),
    ] = None
    metrics: Annotated[
        Metrics | None,
        Field(description="Metrics are a list of metrics emitted from this template"),
    ] = None
    name: Annotated[str | None, Field(description="Name is the name of the template")] = None
    node_selector: Annotated[
        dict[str, str] | None,
        Field(
            alias="nodeSelector",
            description=(
                "NodeSelector is a selector to schedule this step of the workflow to be"
                " run on the selected node(s). Overrides the selector set at the"
                " workflow level."
            ),
        ),
    ] = None
    outputs: Annotated[
        Outputs | None,
        Field(description=("Outputs describe the parameters and artifacts that this template produces")),
    ] = None
    parallelism: Annotated[
        int | None,
        Field(
            description=(
                "Parallelism limits the max total parallel pods that can execute at the"
                " same time within the boundaries of this template invocation. If"
                " additional steps/dag templates are invoked, the pods created by those"
                " templates will not be counted towards this total."
            )
        ),
    ] = None
    plugin: Annotated[
        Plugin | None,
        Field(
            description=(
                "Plugin is a plugin template Note: the structure of a plugin template"
                " is free-form, so we need to have"
                ' "x-kubernetes-preserve-unknown-fields: true" in the validation'
                " schema."
            )
        ),
    ] = None
    pod_spec_patch: Annotated[
        str | None,
        Field(
            alias="podSpecPatch",
            description=(
                "PodSpecPatch holds strategic merge patch to apply against the pod"
                " spec. Allows parameterization of container fields which are not"
                " strings (e.g. resource limits)."
            ),
        ),
    ] = None
    priority_class_name: Annotated[
        str | None,
        Field(
            alias="priorityClassName",
            description="PriorityClassName to apply to workflow pods.",
        ),
    ] = None
    resource: Annotated[
        ResourceTemplate | None,
        Field(description="Resource template subtype which can run k8s resources"),
    ] = None
    retry_strategy: Annotated[
        RetryStrategy | None,
        Field(
            alias="retryStrategy",
            description="RetryStrategy describes how to retry a template when it fails",
        ),
    ] = None
    scheduler_name: Annotated[
        str | None,
        Field(
            alias="schedulerName",
            description=(
                "If specified, the pod will be dispatched by specified scheduler. Or it"
                " will be dispatched by workflow scope scheduler if specified. If"
                " neither specified, the pod will be dispatched by default scheduler."
            ),
        ),
    ] = None
    script: Annotated[
        ScriptTemplate | None,
        Field(description="Script runs a portion of code against an interpreter"),
    ] = None
    security_context: Annotated[
        v1.PodSecurityContext | None,
        Field(
            alias="securityContext",
            description=(
                "SecurityContext holds pod-level security attributes and common"
                " container settings. Optional: Defaults to empty.  See type"
                " description for default values of each field."
            ),
        ),
    ] = None
    service_account_name: Annotated[
        str | None,
        Field(
            alias="serviceAccountName",
            description="ServiceAccountName to apply to workflow pods",
        ),
    ] = None
    sidecars: Annotated[
        list[UserContainer] | None,
        Field(
            description=(
                "Sidecars is a list of containers which run alongside the main"
                " container Sidecars are automatically killed when the main container"
                " completes"
            )
        ),
    ] = None
    steps: Annotated[
        list[ParallelSteps] | None,
        Field(description="Steps define a series of sequential/parallel workflow steps"),
    ] = None
    suspend: Annotated[
        SuspendTemplate | None,
        Field(description=("Suspend template subtype which can suspend a workflow when reaching the step")),
    ] = None
    synchronization: Annotated[
        Synchronization | None,
        Field(description=("Synchronization holds synchronization lock configuration for this template")),
    ] = None
    timeout: Annotated[
        str | None,
        Field(
            description=(
                "Timeout allows to set the total node execution timeout duration"
                " counting from the node's start time. This duration also includes time"
                " in which the node spends in Pending state. This duration may not be"
                " applied to Step or DAG templates."
            )
        ),
    ] = None
    tolerations: Annotated[
        list[v1.Toleration] | None,
        Field(description="Tolerations to apply to workflow pods."),
    ] = None
    volumes: Annotated[
        list[v1.Volume] | None,
        Field(description=("Volumes is a list of volumes that can be mounted by containers in a template.")),
    ] = None


class DAGTask(APIBaseModel):
    arguments: Annotated[
        Arguments | None,
        Field(description=("Arguments are the parameter and artifact arguments to the template")),
    ] = None
    continue_on: Annotated[
        ContinueOn | None,
        Field(
            alias="continueOn",
            description=(
                "ContinueOn makes argo to proceed with the following step even if this"
                " step fails. Errors and Failed states can be specified"
            ),
        ),
    ] = None
    dependencies: Annotated[
        list[str] | None,
        Field(description="Dependencies are name of other targets which this depends on"),
    ] = None
    depends: Annotated[
        str | None,
        Field(description="Depends are name of other targets which this depends on"),
    ] = None
    hooks: Annotated[
        dict[str, LifecycleHook] | None,
        Field(
            description=(
                "Hooks hold the lifecycle hook which is invoked at lifecycle of task,"
                " irrespective of the success, failure, or error status of the primary"
                " task"
            )
        ),
    ] = None
    inline: Annotated[
        Template | None,
        Field(
            description=(
                "Inline is the template. Template must be empty if this is declared"
                " (and vice-versa). Note: As mentioned in the corresponding definition"
                " in WorkflowStep, this struct is defined recursively, so we need"
                ' "x-kubernetes-preserve-unknown-fields: true" in the validation'
                " schema."
            )
        ),
    ] = None
    name: Annotated[str, Field(description="Name is the name of the target")]
    on_exit: Annotated[
        str | None,
        Field(
            alias="onExit",
            description=(
                "OnExit is a template reference which is invoked at the end of the"
                " template, irrespective of the success, failure, or error of the"
                " primary template. DEPRECATED: Use Hooks[exit].Template instead."
            ),
        ),
    ] = None
    template: Annotated[str | None, Field(description="Name of template to execute")] = None
    template_ref: Annotated[
        TemplateRef | None,
        Field(
            alias="templateRef",
            description=("TemplateRef is the reference to the template resource to execute."),
        ),
    ] = None
    when: Annotated[
        str | None,
        Field(description=("When is an expression in which the task should conditionally execute")),
    ] = None
    with_items: Annotated[
        list[Item] | None,
        Field(
            alias="withItems",
            description=(
                "WithItems expands a task into multiple parallel tasks from the items"
                " in the list Note: The structure of WithItems is free-form, so we need"
                ' "x-kubernetes-preserve-unknown-fields: true" in the validation'
                " schema."
            ),
        ),
    ] = None
    with_param: Annotated[
        str | None,
        Field(
            alias="withParam",
            description=(
                "WithParam expands a task into multiple parallel tasks from the value"
                " in the parameter, which is expected to be a JSON list."
            ),
        ),
    ] = None
    with_sequence: Annotated[
        Sequence | None,
        Field(
            alias="withSequence",
            description="WithSequence expands a task into a numeric sequence",
        ),
    ] = None


class WorkflowSpec(APIBaseModel):
    active_deadline_seconds: Annotated[
        int | None,
        Field(
            alias="activeDeadlineSeconds",
            description=(
                "Optional duration in seconds relative to the workflow start time which"
                " the workflow is allowed to run before the controller terminates the"
                " io.argoproj.workflow.v1alpha1. A value of zero is used to terminate a"
                " Running workflow"
            ),
        ),
    ] = None
    affinity: Annotated[
        v1.Affinity | None,
        Field(
            description=(
                "Affinity sets the scheduling constraints for all pods in the"
                " io.argoproj.workflow.v1alpha1. Can be overridden by an affinity"
                " specified in the template"
            )
        ),
    ] = None
    archive_logs: Annotated[
        bool | None,
        Field(
            alias="archiveLogs",
            description=("ArchiveLogs indicates if the container logs should be archived"),
        ),
    ] = None
    arguments: Annotated[
        Arguments | None,
        Field(
            description=(
                "Arguments contain the parameters and artifacts sent to the workflow"
                " entrypoint Parameters are referencable globally using the 'workflow'"
                " variable prefix. e.g."
                " {{io.argoproj.workflow.v1alpha1.parameters.myparam}}"
            )
        ),
    ] = None
    artifact_gc: Annotated[
        WorkflowLevelArtifactGC | None,
        Field(
            alias="artifactGC",
            description=(
                "ArtifactGC describes the strategy to use when deleting artifacts from"
                " completed or deleted workflows (applies to all output Artifacts"
                " unless Artifact.ArtifactGC is specified, which overrides this)"
            ),
        ),
    ] = None
    artifact_repository_ref: Annotated[
        ArtifactRepositoryRef | None,
        Field(
            alias="artifactRepositoryRef",
            description=(
                "ArtifactRepositoryRef specifies the configMap name and key containing the artifact repository config."
            ),
        ),
    ] = None
    automount_service_account_token: Annotated[
        bool | None,
        Field(
            alias="automountServiceAccountToken",
            description=(
                "AutomountServiceAccountToken indicates whether a service account token"
                " should be automatically mounted in pods. ServiceAccountName of"
                " ExecutorConfig must be specified if this value is false."
            ),
        ),
    ] = None
    dns_config: Annotated[
        v1.PodDNSConfig | None,
        Field(
            alias="dnsConfig",
            description=(
                "PodDNSConfig defines the DNS parameters of a pod in addition to those generated from DNSPolicy."
            ),
        ),
    ] = None
    dns_policy: Annotated[
        str | None,
        Field(
            alias="dnsPolicy",
            description=(
                'Set DNS policy for workflow pods. Defaults to "ClusterFirst". Valid'
                " values are 'ClusterFirstWithHostNet', 'ClusterFirst', 'Default'"
                " or 'None'. DNS parameters given in DNSConfig will be merged with"
                " the policy selected with DNSPolicy. To have DNS options set along"
                " with hostNetwork, you have to specify DNS policy explicitly to"
                " 'ClusterFirstWithHostNet'."
            ),
        ),
    ] = None
    entrypoint: Annotated[
        str | None,
        Field(
            description=(
                "Entrypoint is a template reference to the starting point of the io.argoproj.workflow.v1alpha1."
            )
        ),
    ] = None
    executor: Annotated[
        ExecutorConfig | None,
        Field(
            description=("Executor holds configurations of executor containers of the io.argoproj.workflow.v1alpha1.")
        ),
    ] = None
    hooks: Annotated[
        dict[str, LifecycleHook] | None,
        Field(
            description=(
                "Hooks holds the lifecycle hook which is invoked at lifecycle of step,"
                " irrespective of the success, failure, or error status of the primary"
                " step"
            )
        ),
    ] = None
    host_aliases: Annotated[list[v1.HostAlias] | None, Field(alias="hostAliases")] = None
    host_network: Annotated[
        bool | None,
        Field(
            alias="hostNetwork",
            description=("Host networking requested for this workflow pod. Default to false."),
        ),
    ] = None
    image_pull_secrets: Annotated[
        list[v1.LocalObjectReference] | None,
        Field(
            alias="imagePullSecrets",
            description=(
                "ImagePullSecrets is a list of references to secrets in the same"
                " namespace to use for pulling any images in pods that reference this"
                " ServiceAccount. ImagePullSecrets are distinct from Secrets because"
                " Secrets can be mounted in the pod, but ImagePullSecrets are only"
                " accessed by the kubelet. More info:"
                " https://kubernetes.io/docs/concepts/containers/images/#specifying-imagepullsecrets-on-a-pod"
            ),
        ),
    ] = None
    metrics: Annotated[
        Metrics | None,
        Field(description="Metrics are a list of metrics emitted from this Workflow"),
    ] = None
    node_selector: Annotated[
        dict[str, str] | None,
        Field(
            alias="nodeSelector",
            description=(
                "NodeSelector is a selector which will result in all pods of the"
                " workflow to be scheduled on the selected node(s). This is able to be"
                " overridden by a nodeSelector specified in the template."
            ),
        ),
    ] = None
    on_exit: Annotated[
        str | None,
        Field(
            alias="onExit",
            description=(
                "OnExit is a template reference which is invoked at the end of the"
                " workflow, irrespective of the success, failure, or error of the"
                " primary io.argoproj.workflow.v1alpha1."
            ),
        ),
    ] = None
    parallelism: Annotated[
        int | None,
        Field(
            description=(
                "Parallelism limits the max total parallel pods that can execute at the same time in a workflow"
            )
        ),
    ] = None
    pod_disruption_budget: Annotated[
        v1_2.PodDisruptionBudgetSpec | None,
        Field(
            alias="podDisruptionBudget",
            description=(
                "PodDisruptionBudget holds the number of concurrent disruptions that"
                " you allow for Workflow's Pods. Controller will automatically add the"
                " selector with workflow name, if selector is empty. Optional: Defaults"
                " to empty."
            ),
        ),
    ] = None
    pod_gc: Annotated[
        PodGC | None,
        Field(
            alias="podGC",
            description=("PodGC describes the strategy to use when deleting completed pods"),
        ),
    ] = None
    pod_metadata: Annotated[
        Metadata | None,
        Field(
            alias="podMetadata",
            description=("PodMetadata defines additional metadata that should be applied to workflow pods"),
        ),
    ] = None
    pod_priority_class_name: Annotated[
        str | None,
        Field(
            alias="podPriorityClassName",
            description="PriorityClassName to apply to workflow pods.",
        ),
    ] = None
    pod_spec_patch: Annotated[
        str | None,
        Field(
            alias="podSpecPatch",
            description=(
                "PodSpecPatch holds strategic merge patch to apply against the pod"
                " spec. Allows parameterization of container fields which are not"
                " strings (e.g. resource limits)."
            ),
        ),
    ] = None
    priority: Annotated[
        int | None,
        Field(
            description=(
                "Priority is used if controller is configured to process limited number"
                " of workflows in parallel. Workflows with higher priority are"
                " processed first."
            )
        ),
    ] = None
    retry_strategy: Annotated[
        RetryStrategy | None,
        Field(
            alias="retryStrategy",
            description=("RetryStrategy for all templates in the io.argoproj.workflow.v1alpha1."),
        ),
    ] = None
    scheduler_name: Annotated[
        str | None,
        Field(
            alias="schedulerName",
            description=(
                "Set scheduler name for all pods. Will be overridden if"
                " container/script template's scheduler name is set. Default scheduler"
                " will be used if neither specified."
            ),
        ),
    ] = None
    security_context: Annotated[
        v1.PodSecurityContext | None,
        Field(
            alias="securityContext",
            description=(
                "SecurityContext holds pod-level security attributes and common"
                " container settings. Optional: Defaults to empty.  See type"
                " description for default values of each field."
            ),
        ),
    ] = None
    service_account_name: Annotated[
        str | None,
        Field(
            alias="serviceAccountName",
            description=("ServiceAccountName is the name of the ServiceAccount to run all pods of the workflow as."),
        ),
    ] = None
    shutdown: Annotated[
        str | None,
        Field(description=("Shutdown will shutdown the workflow according to its ShutdownStrategy")),
    ] = None
    suspend: Annotated[
        bool | None,
        Field(
            description=("Suspend will suspend the workflow and prevent execution of any future steps in the workflow")
        ),
    ] = None
    synchronization: Annotated[
        Synchronization | None,
        Field(description=("Synchronization holds synchronization lock configuration for this Workflow")),
    ] = None
    template_defaults: Annotated[
        Template | None,
        Field(
            alias="templateDefaults",
            description=(
                "TemplateDefaults holds default template values that will apply to all"
                " templates in the Workflow, unless overridden on the template-level"
            ),
        ),
    ] = None
    templates: Annotated[
        list[Template] | None,
        Field(description="Templates is a list of workflow templates used in a workflow"),
    ] = None
    tolerations: Annotated[
        list[v1.Toleration] | None,
        Field(description="Tolerations to apply to workflow pods."),
    ] = None
    ttl_strategy: Annotated[
        TTLStrategy | None,
        Field(
            alias="ttlStrategy",
            description=(
                "TTLStrategy limits the lifetime of a Workflow that has finished"
                " execution depending on if it Succeeded or Failed. If this struct is"
                " set, once the Workflow finishes, it will be deleted after the time to"
                " live expires. If this field is unset, the controller config map will"
                " hold the default values."
            ),
        ),
    ] = None
    volume_claim_gc: Annotated[
        VolumeClaimGC | None,
        Field(
            alias="volumeClaimGC",
            description=("VolumeClaimGC describes the strategy to use when deleting volumes from completed workflows"),
        ),
    ] = None
    volume_claim_templates: Annotated[
        list[v1.PersistentVolumeClaim] | None,
        Field(
            alias="volumeClaimTemplates",
            description=(
                "VolumeClaimTemplates is a list of claims that containers are allowed"
                " to reference. The Workflow controller will create the claims at the"
                " beginning of the workflow and delete the claims upon completion of"
                " the workflow"
            ),
        ),
    ] = None
    volumes: Annotated[
        list[v1.Volume] | None,
        Field(
            description=(
                "Volumes is a list of volumes that can be mounted by containers in a io.argoproj.workflow.v1alpha1."
            )
        ),
    ] = None
    workflow_metadata: Annotated[
        WorkflowMetadata | None,
        Field(
            alias="workflowMetadata",
            description=("WorkflowMetadata contains some metadata of the workflow to refer to"),
        ),
    ] = None
    workflow_template_ref: Annotated[
        WorkflowTemplateRef | None,
        Field(
            alias="workflowTemplateRef",
            description=("WorkflowTemplateRef holds a reference to a WorkflowTemplate for execution"),
        ),
    ] = None


class WorkflowStep(APIBaseModel):
    arguments: Annotated[Arguments | None, Field(description="Arguments hold arguments to the template")] = None
    continue_on: Annotated[
        ContinueOn | None,
        Field(
            alias="continueOn",
            description=(
                "ContinueOn makes argo to proceed with the following step even if this"
                " step fails. Errors and Failed states can be specified"
            ),
        ),
    ] = None
    hooks: Annotated[
        dict[str, LifecycleHook] | None,
        Field(
            description=(
                "Hooks holds the lifecycle hook which is invoked at lifecycle of step,"
                " irrespective of the success, failure, or error status of the primary"
                " step"
            )
        ),
    ] = None
    inline: Annotated[
        Template | None,
        Field(
            description=(
                "Inline is the template. Template must be empty if this is declared"
                " (and vice-versa). Note: This struct is defined recursively, since the"
                " inline template can potentially contain steps/DAGs that also has an"
                ' "inline" field. Kubernetes doesn\'t allow recursive types, so we need'
                ' "x-kubernetes-preserve-unknown-fields: true" in the validation'
                " schema."
            )
        ),
    ] = None
    name: Annotated[str | None, Field(description="Name of the step")] = None
    on_exit: Annotated[
        str | None,
        Field(
            alias="onExit",
            description=(
                "OnExit is a template reference which is invoked at the end of the"
                " template, irrespective of the success, failure, or error of the"
                " primary template. DEPRECATED: Use Hooks[exit].Template instead."
            ),
        ),
    ] = None
    template: Annotated[
        str | None,
        Field(description="Template is the name of the template to execute as the step"),
    ] = None
    template_ref: Annotated[
        TemplateRef | None,
        Field(
            alias="templateRef",
            description=("TemplateRef is the reference to the template resource to execute as the step."),
        ),
    ] = None
    when: Annotated[
        str | None,
        Field(description=("When is an expression in which the step should conditionally execute")),
    ] = None
    with_items: Annotated[
        list[Item] | None,
        Field(
            alias="withItems",
            description=(
                "WithItems expands a step into multiple parallel steps from the items"
                " in the list Note: The structure of WithItems is free-form, so we need"
                ' "x-kubernetes-preserve-unknown-fields: true" in the validation'
                " schema."
            ),
        ),
    ] = None
    with_param: Annotated[
        str | None,
        Field(
            alias="withParam",
            description=(
                "WithParam expands a step into multiple parallel steps from the value"
                " in the parameter, which is expected to be a JSON list."
            ),
        ),
    ] = None
    with_sequence: Annotated[
        Sequence | None,
        Field(
            alias="withSequence",
            description="WithSequence expands a step into a numeric sequence",
        ),
    ] = None


class ClusterWorkflowTemplate(APIBaseModel):
    api_version: Annotated[
        str | None,
        Field(
            alias="apiVersion",
            description=(
                "APIVersion defines the versioned schema of this representation of an"
                " object. Servers should convert recognized schemas to the latest"
                " internal value, and may reject unrecognized values. More info:"
                " https://git.io.k8s.community/contributors/devel/sig-architecture/api-conventions.md#resources"
            ),
        ),
    ] = None
    kind: Annotated[
        str | None,
        Field(
            description=(
                "Kind is a string value representing the REST resource this object"
                " represents. Servers may infer this from the endpoint the client"
                " submits requests to. Cannot be updated. In CamelCase. More info:"
                " https://git.io.k8s.community/contributors/devel/sig-architecture/api-conventions.md#types-kinds"
            )
        ),
    ] = None
    metadata: v1_1.ObjectMeta
    spec: WorkflowSpec


class CronWorkflowSpec(APIBaseModel):
    concurrency_policy: Annotated[
        str | None,
        Field(
            alias="concurrencyPolicy",
            description=("ConcurrencyPolicy is the K8s-style concurrency policy that will be used"),
        ),
    ] = None
    failed_jobs_history_limit: Annotated[
        int | None,
        Field(
            alias="failedJobsHistoryLimit",
            description=("FailedJobsHistoryLimit is the number of failed jobs to be kept at a time"),
        ),
    ] = None
    schedule: Annotated[
        str | None,
        Field(description=("Schedule is a schedule to run the Workflow in Cron format. Deprecated, use Schedules")),
    ] = None
    schedules: Annotated[
        list[str] | None,
        Field(description=("v3.6 and after: Schedules is a list of schedules to run the Workflow in Cron format")),
    ] = None
    starting_deadline_seconds: Annotated[
        int | None,
        Field(
            alias="startingDeadlineSeconds",
            description=(
                "StartingDeadlineSeconds is the K8s-style deadline that will limit the"
                " time a CronWorkflow will be run after its original scheduled time if"
                " it is missed."
            ),
        ),
    ] = None
    stop_strategy: Annotated[
        StopStrategy | None,
        Field(
            alias="stopStrategy",
            description=(
                "v3.6 and after: StopStrategy defines if the CronWorkflow should stop scheduling based on a condition"
            ),
        ),
    ] = None
    successful_jobs_history_limit: Annotated[
        int | None,
        Field(
            alias="successfulJobsHistoryLimit",
            description=("SuccessfulJobsHistoryLimit is the number of successful jobs to be kept at a time"),
        ),
    ] = None
    suspend: Annotated[
        bool | None,
        Field(description=("Suspend is a flag that will stop new CronWorkflows from running if set to true")),
    ] = None
    timezone: Annotated[
        str | None,
        Field(
            description=(
                "Timezone is the timezone against which the cron schedule will be"
                ' calculated, e.g. "Asia/Tokyo". Default is machine\'s local time.'
            )
        ),
    ] = None
    when: Annotated[
        str | None,
        Field(description=("v3.6 and after: When is an expression that determines if a run should be scheduled.")),
    ] = None
    workflow_metadata: Annotated[
        v1_1.ObjectMeta | None,
        Field(
            alias="workflowMetadata",
            description=("WorkflowMetadata contains some metadata of the workflow to be run"),
        ),
    ] = None
    workflow_spec: Annotated[
        WorkflowSpec,
        Field(
            alias="workflowSpec",
            description="WorkflowSpec is the spec of the workflow to be run",
        ),
    ]


class WorkflowStatus(APIBaseModel):
    artifact_gc_status: Annotated[
        ArtGCStatus | None,
        Field(
            alias="artifactGCStatus",
            description=("ArtifactGCStatus maintains the status of Artifact Garbage Collection"),
        ),
    ] = None
    artifact_repository_ref: Annotated[
        ArtifactRepositoryRefStatus | None,
        Field(
            alias="artifactRepositoryRef",
            description=(
                "ArtifactRepositoryRef is used to cache the repository to use so we do"
                " not need to determine it everytime we reconcile."
            ),
        ),
    ] = None
    compressed_nodes: Annotated[
        str | None,
        Field(
            alias="compressedNodes",
            description="Compressed and base64 decoded Nodes map",
        ),
    ] = None
    conditions: Annotated[
        list[Condition] | None,
        Field(description="Conditions is a list of conditions the Workflow may have"),
    ] = None
    estimated_duration: Annotated[
        int | None,
        Field(alias="estimatedDuration", description="EstimatedDuration in seconds."),
    ] = None
    finished_at: Annotated[
        v1_1.Time | None,
        Field(alias="finishedAt", description="Time at which this workflow completed"),
    ] = None
    message: Annotated[
        str | None,
        Field(
            description=("A human readable message indicating details about why the workflow is in this condition.")
        ),
    ] = None
    nodes: Annotated[
        dict[str, NodeStatus] | None,
        Field(description="Nodes is a mapping between a node ID and the node's status."),
    ] = None
    offload_node_status_version: Annotated[
        str | None,
        Field(
            alias="offloadNodeStatusVersion",
            description=(
                "Whether on not node status has been offloaded to a database. If"
                " exists, then Nodes and CompressedNodes will be empty. This will"
                " actually be populated with a hash of the offloaded data."
            ),
        ),
    ] = None
    outputs: Annotated[
        Outputs | None,
        Field(
            description=(
                "Outputs captures output values and artifact locations produced by the workflow via global outputs"
            )
        ),
    ] = None
    persistent_volume_claims: Annotated[
        list[v1.Volume] | None,
        Field(
            alias="persistentVolumeClaims",
            description=(
                "PersistentVolumeClaims tracks all PVCs that were created as part of"
                " the io.argoproj.workflow.v1alpha1. The contents of this list are"
                " drained at the end of the workflow."
            ),
        ),
    ] = None
    phase: Annotated[
        str | None,
        Field(
            description=(
                "Phase a simple, high-level summary of where the workflow is in its"
                ' lifecycle. Will be "" (Unknown), "Pending", or "Running" before the'
                ' workflow is completed, and "Succeeded", "Failed" or "Error" once the'
                " workflow has completed."
            )
        ),
    ] = None
    progress: Annotated[str | None, Field(description="Progress to completion")] = None
    resources_duration: Annotated[
        dict[str, int] | None,
        Field(
            alias="resourcesDuration",
            description="ResourcesDuration is the total for the workflow",
        ),
    ] = None
    started_at: Annotated[
        v1_1.Time | None,
        Field(alias="startedAt", description="Time at which this workflow started"),
    ] = None
    stored_templates: Annotated[
        dict[str, Template] | None,
        Field(
            alias="storedTemplates",
            description=("StoredTemplates is a mapping between a template ref and the node's status."),
        ),
    ] = None
    stored_workflow_template_spec: Annotated[
        WorkflowSpec | None,
        Field(
            alias="storedWorkflowTemplateSpec",
            description=("StoredWorkflowSpec stores the WorkflowTemplate spec for future execution."),
        ),
    ] = None
    synchronization: Annotated[
        SynchronizationStatus | None,
        Field(description="Synchronization stores the status of synchronization locks"),
    ] = None
    task_results_completion_status: Annotated[
        dict[str, bool] | None,
        Field(
            alias="taskResultsCompletionStatus",
            description=(
                "TaskResultsCompletionStatus tracks task result completion status"
                " (mapped by node ID). Used to prevent premature archiving and garbage"
                " collection."
            ),
        ),
    ] = None


class WorkflowTemplate(APIBaseModel):
    api_version: Annotated[
        str | None,
        Field(
            alias="apiVersion",
            description=(
                "APIVersion defines the versioned schema of this representation of an"
                " object. Servers should convert recognized schemas to the latest"
                " internal value, and may reject unrecognized values. More info:"
                " https://git.io.k8s.community/contributors/devel/sig-architecture/api-conventions.md#resources"
            ),
        ),
    ] = None
    kind: Annotated[
        str | None,
        Field(
            description=(
                "Kind is a string value representing the REST resource this object"
                " represents. Servers may infer this from the endpoint the client"
                " submits requests to. Cannot be updated. In CamelCase. More info:"
                " https://git.io.k8s.community/contributors/devel/sig-architecture/api-conventions.md#types-kinds"
            )
        ),
    ] = None
    metadata: v1_1.ObjectMeta
    spec: WorkflowSpec


class ClusterWorkflowTemplateCreateRequest(APIBaseModel):
    create_options: Annotated[v1_1.CreateOptions | None, Field(alias="createOptions")] = None
    template: ClusterWorkflowTemplate | None = None


class ClusterWorkflowTemplateLintRequest(APIBaseModel):
    create_options: Annotated[v1_1.CreateOptions | None, Field(alias="createOptions")] = None
    template: ClusterWorkflowTemplate | None = None


class ClusterWorkflowTemplateUpdateRequest(APIBaseModel):
    name: Annotated[str | None, Field(description="DEPRECATED: This field is ignored.")] = None
    template: ClusterWorkflowTemplate | None = None


class CronWorkflow(APIBaseModel):
    api_version: Annotated[
        str | None,
        Field(
            alias="apiVersion",
            description=(
                "APIVersion defines the versioned schema of this representation of an"
                " object. Servers should convert recognized schemas to the latest"
                " internal value, and may reject unrecognized values. More info:"
                " https://git.io.k8s.community/contributors/devel/sig-architecture/api-conventions.md#resources"
            ),
        ),
    ] = None
    kind: Annotated[
        str | None,
        Field(
            description=(
                "Kind is a string value representing the REST resource this object"
                " represents. Servers may infer this from the endpoint the client"
                " submits requests to. Cannot be updated. In CamelCase. More info:"
                " https://git.io.k8s.community/contributors/devel/sig-architecture/api-conventions.md#types-kinds"
            )
        ),
    ] = None
    metadata: v1_1.ObjectMeta
    spec: CronWorkflowSpec
    status: CronWorkflowStatus | None = None


class Workflow(APIBaseModel):
    api_version: Annotated[
        str | None,
        Field(
            alias="apiVersion",
            description=(
                "APIVersion defines the versioned schema of this representation of an"
                " object. Servers should convert recognized schemas to the latest"
                " internal value, and may reject unrecognized values. More info:"
                " https://git.io.k8s.community/contributors/devel/sig-architecture/api-conventions.md#resources"
            ),
        ),
    ] = None
    kind: Annotated[
        str | None,
        Field(
            description=(
                "Kind is a string value representing the REST resource this object"
                " represents. Servers may infer this from the endpoint the client"
                " submits requests to. Cannot be updated. In CamelCase. More info:"
                " https://git.io.k8s.community/contributors/devel/sig-architecture/api-conventions.md#types-kinds"
            )
        ),
    ] = None
    metadata: v1_1.ObjectMeta
    spec: WorkflowSpec
    status: WorkflowStatus | None = None


class WorkflowTemplateCreateRequest(APIBaseModel):
    create_options: Annotated[v1_1.CreateOptions | None, Field(alias="createOptions")] = None
    namespace: str | None = None
    template: WorkflowTemplate | None = None


class WorkflowTemplateLintRequest(APIBaseModel):
    create_options: Annotated[v1_1.CreateOptions | None, Field(alias="createOptions")] = None
    namespace: str | None = None
    template: WorkflowTemplate | None = None


class WorkflowTemplateUpdateRequest(APIBaseModel):
    name: Annotated[str | None, Field(description="DEPRECATED: This field is ignored.")] = None
    namespace: str | None = None
    template: WorkflowTemplate | None = None


class CreateCronWorkflowRequest(APIBaseModel):
    create_options: Annotated[v1_1.CreateOptions | None, Field(alias="createOptions")] = None
    cron_workflow: Annotated[CronWorkflow | None, Field(alias="cronWorkflow")] = None
    namespace: str | None = None


class LintCronWorkflowRequest(APIBaseModel):
    cron_workflow: Annotated[CronWorkflow | None, Field(alias="cronWorkflow")] = None
    namespace: str | None = None


class UpdateCronWorkflowRequest(APIBaseModel):
    cron_workflow: Annotated[CronWorkflow | None, Field(alias="cronWorkflow")] = None
    name: Annotated[str | None, Field(description="DEPRECATED: This field is ignored.")] = None
    namespace: str | None = None


class WorkflowCreateRequest(APIBaseModel):
    create_options: Annotated[v1_1.CreateOptions | None, Field(alias="createOptions")] = None
    instance_id: Annotated[
        str | None,
        Field(alias="instanceID", description="This field is no longer used."),
    ] = None
    namespace: str | None = None
    server_dry_run: Annotated[bool | None, Field(alias="serverDryRun")] = None
    workflow: Workflow | None = None


class WorkflowLintRequest(APIBaseModel):
    namespace: str | None = None
    workflow: Workflow | None = None


class WorkflowWatchEvent(APIBaseModel):
    object: Annotated[Workflow | None, Field(title="the workflow")] = None
    type: Annotated[str | None, Field(title="the type of change")] = None


class ParallelSteps(RootModel[list[WorkflowStep]]):
    root: list[WorkflowStep]


DAGTemplate.model_rebuild()
ClusterWorkflowTemplateList.model_rebuild()
CronWorkflowList.model_rebuild()
WorkflowList.model_rebuild()
WorkflowTemplateList.model_rebuild()
Template.model_rebuild()
