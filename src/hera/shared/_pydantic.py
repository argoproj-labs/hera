"""Module that holds the underlying base Pydantic models for Hera objects."""

from collections import ChainMap
from inspect import get_annotations
from typing import Any, Dict, Type

from pydantic import (
    VERSION,
    BaseModel as V2BaseModel,
    ConfigDict,
)
from pydantic.fields import FieldInfo
from pydantic.v1 import (
    BaseModel as V1BaseModel,
    Field,
    PrivateAttr,
    ValidationError,
    root_validator,
    validator,
)

_PYDANTIC_VERSION: int = int(VERSION.split(".")[0])


def get_fields(cls: Type[V1BaseModel] | Type[V2BaseModel]) -> Dict[str, FieldInfo]:
    """Centralize access to __fields__."""
    try:
        return cls.model_fields  # type: ignore
    except AttributeError:
        return cls.__fields__  # type: ignore


def model_dump(obj: V1BaseModel | V2BaseModel) -> Dict[str, Any]:
    """Call model_dump, with V1 fallback."""
    if isinstance(obj, V1BaseModel):
        return obj.dict()
    return obj.model_dump(warnings="none")


def get_field_annotations(cls: Type[V1BaseModel] | Type[V2BaseModel]) -> Dict[str, Any]:
    return {k: v for k, v in ChainMap(*(get_annotations(c) for c in cls.__mro__)).items()}


class APIBaseModel(V2BaseModel):
    """BaseModel for the API classes generated by datamodel codegen."""

    model_config = ConfigDict(
        populate_by_name=True,
        frozen=False,
        use_enum_values=True,
        arbitrary_types_allowed=True,
        extra="forbid",
    )


__all__ = [
    "APIBaseModel",
    "Field",
    "FieldInfo",
    "PrivateAttr",
    "V1BaseModel",  # Export for serialization.py to cover user-defined models
    "ValidationError",
    "root_validator",
    "validator",
]
