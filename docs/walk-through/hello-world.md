# Hello World

Let's take a look at the `hello_world.py` from the [Quick Start](./quick-start.md) guide.

```py
from hera.workflows import Steps, Workflow, WorkflowsService, script


@script()
def echo(message: str):
    print(message)


with Workflow(
    generate_name="hello-world-",
    entrypoint="steps",
    namespace="argo",
    workflows_service=WorkflowsService(host="https://localhost:2746")
) as w:
    with Steps(name="steps"):
        echo(arguments={"message": "Hello world!"})

w.create()
```

## The imports

Hera provides many specialised classes in `hera.workflows`. You will see the Argo Workflows spec has been transformed
into powerful Python classes. Hera also provides classes autogenerated from the spec in `hera.workflows.models`.

## Using **Any Function** on Argo

We can use Hera's `script` decorator to turn any function into a
[Script template](https://argoproj.github.io/argo-workflows/workflow-concepts/#script), which is mirrored in Hera as the
`Script` class. For this Workflow, we have wrapped the `print` function in our `echo` function so that we can decorate
it.

### The `script` Decorator

The `script` decorator can take the kwargs that a `Script` [can take](../api/workflows/hera.md#hera.workflows.Script),
including `image`, `volumes`, `env`, and many more. This is how we can specify a different `image` of Python to use
instead of the default `python:3.9` for your script:

```py
@script(image="python:3.13")
def echo(message: str):
    print(message)
```

Alternatively, you can specify this image just once by using the `global_config.image` variable, and it will be used for
all script templates automatically:

```py
from hera.shared import global_config
global_config.image = "python:3.13"

@script()  # "echo" will now run using python:3.13
def echo(message: str):
    print(message)

@script()  # "echo_twice" will also run using python:3.13
def echo_twice(message: str):
    print(message)
    print(message)
```

To learn more about the script decorator, see the
[Script Basics user guide](../user-guides/script-basics.md#script-decorator).

## The Workflow Context Manager

The Workflow context manager acts as a scope under which `template` Hera objects can be declared, which include
Containers, Scripts, DAGs [and more](https://argoproj.github.io/argo-workflows/workflow-concepts/#template-types). You
can provide values for the Workflow itself:

```py
with Workflow(
    generate_name="hello-world-",
    entrypoint="steps",
    namespace="argo",
    workflows_service=WorkflowsService(host="https://localhost:2746")
) as w:
```

* `generate_name` is used by Argo to create a name by appending a random 5 character suffix, so you may see this
  Workflow run with a name like `hello-world-vmsz5`.
* `entrypoint` tells Argo which template to run upon submission.
* `namespace` is the Kubernetes namespace you want to run the Workflow in.
* `workflows_service` is Hera's REST API submission service.

## The Steps Context Manager

A `Steps` template is the second template type of this example. The `Steps` template is known as a "template invocator",
which is used to coordinate other templates, mainly Containers and Scripts, to do the actual work. In Hera, the `Steps`
class is a context manager; it automatically arranges your templates in the order that you add them, with each
template invocation known as a `Step`.

```py
with Steps(name="steps"):
```

We can then add a `Step` and pass the `arguments` for the function to use:

```py
with Steps(name="steps"):
    echo(arguments={"message": "Hello world!"})
```

Clearly, `echo` takes a `message` argument, but we are passing in a value to `arguments`, this is because the above
snippet is actually syntactic sugar for the following:

```py
with Steps(name="steps"):
    Step(
        name="echo",
        template=Script(name="echo", source=echo, inputs=[Parameter(name="message")]),
        arguments={"message": "Hello world!"},
    )
```

The "callable" syntax for your script templates intends to cut down this boilerplate as much as possible, while keeping
the code intuitive.

## Submitting the Workflow

Finally, with the workflow defined, the actual submisson occurs on

```py
w.create()
```

This uses the `WorkflowsService` to submit to Argo using its REST API, so `w.create()` can be thought of as running
`argo submit` from the CLI.

## Generating YAML

It's important to recognise that Hera is a translation layer for Argo Workflows, which only understands YAML â€“ the YAML
Workflow should be considered the golden source when debugging.

You can generate the YAML for this Workflow using `w.to_yaml()`, or `w.to_file(name="hello-world.yaml")`:

```py
print(w.to_yaml())
```

The YAML for this Workflow looks like:

```yaml
apiVersion: argoproj.io/v1alpha1
kind: Workflow
metadata:
  generateName: hello-world-
  namespace: argo
spec:
  entrypoint: steps
  templates:
  - name: steps
    steps:
    - - name: echo
        template: echo
        arguments:
          parameters:
          - name: message
            value: Hello world!
  - name: echo
    inputs:
      parameters:
      - name: message
    script:
      image: python:3.9
      source: |-
        import os
        import sys
        sys.path.append(os.getcwd())
        import json
        try: message = json.loads(r'''{{inputs.parameters.message}}''')
        except: message = r'''{{inputs.parameters.message}}'''

        print(message)
      command:
      - python
```
